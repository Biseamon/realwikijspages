<!--
title: BBWT3 - Security
description: 
published: true
date: 2020-12-07T16:13:49.730Z
tags: 
editor: ckeditor
dateCreated: 2020-11-27T11:06:33.548Z
-->

<h1>Security&nbsp;</h1>
<h2>Overview</h2>
<p><strong>Note</strong>: “Real” security is about API calls. The “appearance” of security is about (a) page accessibility, (b) menu item visibility. All three are required for a happy customer.</p>
<p>In short, you can think of the "real" part of the BBWT3 security&nbsp;<i>rules</i>&nbsp;as:</p>
<ul>
  <li><strong>Which logged-in users&nbsp;</strong>can have&nbsp;<strong>unrestricted</strong>&nbsp;access to this API method? This is&nbsp;<strong>roles</strong>&nbsp;security. We group those users into sets called roles, e.g. Manager, Administrator, Editor. This is a very simple form of security that is enough for 70% of the security work.</li>
  <li>If a user is restricted from receiving api/documents/1 but may receive api/documents/2 then this is&nbsp;<strong>resource</strong>&nbsp;security. This covers the next 29% of security work. It's necessary for all business-to-business sites. It's common for an intranet site for a large business.</li>
  <li>If a user is&nbsp;<i>sometimes</i>&nbsp;restricted from&nbsp;receiving api/documents/1, but at other times is allowed, then this also requires kind of resource security, which we call&nbsp;<strong>state-based</strong>&nbsp;security<strong>.</strong></li>
</ul>
<p>You will often choose to combine security elements such that you have a test “<i>Is the user in the role ‘Administrator’, failing that, is the user merely trying to access their own data</i>”.</p>
<p>You can see the applied roles security when&nbsp;logged-in as admin at&nbsp;<a href="http://bbwt3-test-windows-aurora.blueberrytest.com/app/routes">http://bbwt3-test-windows-aurora.blueberrytest.com/app/routes</a>&nbsp;. This is achieved by reflection, i.e. the application is reading its own code to find out what roles security has been applied.&nbsp;It would be nice if we could also see the resource-based security there too (31-01-19&nbsp;<a href="https://pts.bbconsult.co.uk/taskEditor?id=158253">#158253</a>).</p>
<h2>Terminology</h2>
<ul>
  <li>Sessions – when a user logs in, they begin a session. A secure cookie is given to the browser that contains information about the user. When that cookie expires by time-out or is otherwise deleted (e.g. by logout), the user needs to log in again to start a new session. The cookie is sent to the server on every call, and the server trust its contents. This is useful because we enter “claims” about the user into the cookie. The cookie can be trusted because it is encrypted so that only the server can read its contents or write to it. If we didn't store the claims in the cookie, then the server would have to check the user's current privileges with the database on every call, which would be a significant performance hit. (Or in the server's memory, which would be faster but would be a break with the RESTful architecture)</li>
  <li>Claims – The database holds claims that are loaded into the cookie when a user logs in. These claims may be “I am an Administrator” or “I am part of the North West region” or “I am part of Gary’s team” or “I am an employee of Acme Ltd” or “I can run faster than 2,000 mph” – anything. Most claims are “I belong to a particular set of users”, most notably “I belong to the particular set of users that have ‘role’ X”, “I belong to the particular set of users that belong to ‘tenant’ Y”, “I belong to the particular set of users that belong to ‘group’ Z”.<ul>
      <li>A claim is expected to&nbsp;<i>typically</i>&nbsp;last for the whole session (31-01-19&nbsp;<a href="https://pts.bbconsult.co.uk/taskEditor?id=158251">#158251</a>).</li>
      <li>Note: Not all security requirements can be expressed in a session-spanning claim. See, for instance state-based security. But almost all of them can. The ones that&nbsp;<i>don’t</i>&nbsp;will&nbsp;<i>often</i>&nbsp;have slower security performance.</li>
    </ul>
  </li>
  <li>Roles – A role is the simplest kind of security. Roles protect an API function with a simple rule: if your role claim is&nbsp;<i>not</i>&nbsp;listed then you are not permitted to access&nbsp;<i><strong>any</strong>&nbsp;data through that function</i>. You may have resource security on top of the same function.</li>
  <li>Resources – An example of the most common form of resource security rule is: "Sales notes created by Gary's team can only be read/edited/deleted by Gary's team; when a user in Gary's team generates a list of Sales notes, only show them the sales notes that were created by Gary's team".</li>
  <li>Groups - For resource-based security, the test is usually “is my groupId claim equal to the &lt;entity&gt;.groupId of the thing”. The specific test can be more complex. There’s no restriction on tests that the groupIds must be on the table/entity of interest – you can navigate your data model to find the group.</li>
  <li>State-based security - Rarely, you may have other resource-based requirements that aren’t specifically about group membership e.g. “if entity Y&nbsp;<i><strong>currently</strong></i>&nbsp;passes a test with respect to the calling user Z”.</li>
</ul>
<p>Tenants – A lot of the literature references multi-tenant systems. Tenants are just another kind of group. What makes “tenants” interesting is that&nbsp;we should&nbsp;often&nbsp;be particularly careful to include tenant id within uniqueness constraints (task 158252). This is so that we don’t leak information between tenants with error messages such as: "Car with registration plate “GCP 225Y” cannot be entered into the system because it is already in the database".</p>
<ul>
  <li>Permissions – BBWT2 cared a lot about ‘permissions’, BBWT3 does not. BBWT2 Permissions were effectively an extra layer between a role and an API function that allowed you to say “with the ‘edit Car’ permission you may call APIs: UpdateCar, CreateCar, DeleteCar; and the roles ‘CarEditor’, 'SiteAdmin' have the ‘edit Car’ permission;&nbsp;”. BBWT3 instead says: “permission to call APIs: UpdateCar, CreateCar, DeleteCar is restricted to the roles ‘CarEditor’, 'SiteAdmin'".</li>
</ul>
<h2>Implementation Details</h2>
<p>&nbsp;</p>
<p>&nbsp;</p>
<ul>
  <li><a href="BBWT3---Acutenix-Testing_85493291.html">BBWT3 - Acutenix Testing</a></li>
  <li><a href="85493303.html">BBWT3 - Application Security / Monitoring</a></li>
  <li><a href="BBWT3---How-Security-Works_85493289.html">BBWT3 - How Security Works</a></li>
</ul>
<p>&nbsp;</p>
<h1>Acutenix Testing&nbsp;</h1>
<h2>Overview</h2>
<p>Blueberry internally uses a popular web-security tool to scan both the core BBWT3 system and customer applications for vulnerabilities on a regular basis. In addition, a number of Blueberry customers have commissioned external penetration tests - the feedback from those tests is worked back into the BBWT3 Core, benefiting all customers using BBWT3.</p>
<ul>
  <li>Automatically scans all webpages of web application.</li>
  <li>Has a low false positive rate.</li>
  <li>Has high detection rate of vulnerabilities.</li>
  <li>Intigrates with various issue trackers.</li>
  <li>Works on Microsoft Windows, as well as Linux.</li>
  <li>Also available as an online tool.</li>
</ul>
<h2>For Project Managers</h2>
<ul>
  <li>All of BBWT3 is tester for against known vulnerabilities, as well as alerting developers to potential attack vectors.</li>
  <li>Tool autonomously searches for these vulnerabilities, but also has the option to test manually.</li>
  <li>Allows developers to make sure their web applicaitons are as secure as possible.</li>
</ul>
<h2>For Marketing</h2>
<ul>
  <li>Blueberry ensures that all web applications made with BBWT3 are secure from all known vulnerabilities, as well as potential vulnerabilities.</li>
  <li>Tests for XSS, SQL injection, SSRF etc.</li>
  <li>Ensuring that your companies, and clients data remains secure.</li>
</ul>
<h1>Discovered Vulnerabilities and Patch Progress&nbsp;</h1>
<p>&nbsp;</p>
<h2>Overview</h2>
<p>This is a table of the recently discovered vulnerabilities found in BBWT2, and how they effect BBWT3</p>
<h2>Vulnerabilities</h2>
<figure class="table">
  <table>
    <thead>
      <tr>
        <th>Issues</th>
        <th><strong>BBWT2 Demo Status</strong></th>
        <th><strong>Push fixes for BBWT2 customers?</strong></th>
        <th><strong>BBWT3 Demo status</strong></th>
        <th><strong>Push fixes for BBWT3 customers?</strong></th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Concern over malicious file upload</td>
        <td>Feature not complete enough in demo to have a fix</td>
        <td>High-risk sites only</td>
        <td>Upload feature not tested?</td>
        <td>N/A?</td>
      </tr>
      <tr>
        <td>Too much diagnostic information emitted</td>
        <td>Mitigated, reference 158535</td>
        <td><i><u>Very</u></i>&nbsp;high-risk sites only</td>
        <td>Mitigated with early design choices</td>
        <td>Already pushed</td>
      </tr>
      <tr>
        <td>Weak password rules</td>
        <td>Mitigated, reference 158535</td>
        <td>High-risk sites only</td>
        <td>Mitigated with early design choices</td>
        <td>Already pushed</td>
      </tr>
      <tr>
        <td>Remove Remember me / Keep me logged-in feature</td>
        <td>Not implemented.</td>
        <td>Consider for high-risk sites only</td>
        <td>Work implicitly in progress. (Jacob’s work)</td>
        <td>Push to all when implemented</td>
      </tr>
      <tr>
        <td>Autocomplete erroneously active on login fields</td>
        <td>Fixed. Not sure when.</td>
        <td>High-risk sites only</td>
        <td>Fixed. Not sure when.</td>
        <td>Believed already pushed</td>
      </tr>
      <tr>
        <td>Insufficiently secured cookie</td>
        <td>Fixed. Reference 155788 and 158535.</td>
        <td>High-risk sites only</td>
        <td>Fixed early. Reference 148373.</td>
        <td>Believed already pushed</td>
      </tr>
      <tr>
        <td>Concurrent user sessions</td>
        <td>No fix recommended</td>
        <td>Not recommended</td>
        <td>Worked on recently</td>
        <td>Not recommended</td>
      </tr>
      <tr>
        <td>Insufficient sanitisation of input</td>
        <td>Not implemented. Recommended solution at 158953.</td>
        <td><i><u>Very</u></i>&nbsp;high-risk sites only</td>
        <td>Implemented with early design choices</td>
        <td>Believed already pushed</td>
      </tr>
      <tr>
        <td colspan="1">Use of known vulnerable JQuery libraries</td>
        <td colspan="1">Not implemented.&nbsp;No fix on demo recommended.</td>
        <td colspan="1">
          <p>Ongoing vigilance required for high-risk sites.</p>
          <p>Not reasonably a "pushable" concern.</p>
        </td>
        <td colspan="1">N/A - JQuery not used</td>
        <td colspan="1">N/A</td>
      </tr>
    </tbody>
  </table>
</figure>
<p>&nbsp;</p>
<h2>Security Items&nbsp;</h2>
<p>The list of security items below is compiled from the 2017 OWASP Top 10 Application Security Risks.&nbsp;</p>
<p>For each risk, a brief example of how the risk is mitigated on BBWT3 projects.</p>
<p>This page is still a draft - more details will be added soon.</p>
<figure class="table" style="width:1219.0px;">
  <table>
    <thead>
      <tr>
        <th>Item</th>
        <th>Brief Description</th>
        <th>How This Is Addressed in BBWT3</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a href="85493311.html">A1:2017- Injection</a></td>
        <td>
          <p>An attacker enters hostile data into the website to trick the web server into executing unintended commands or accessing data without proper authorisation.</p>
          <p>Injection flaws occur when the site's interpreters cannot correctly distinguish which parts of a command are untrusted input data and which parts are a trusted command.</p>
          <p>Example outcome: An attacker with a user account is able to access sensitive data belonging to another user.</p>
        </td>
        <td>Use of LINQ (Language INtegrated Queries) which automatically tags the input data separately from the commands.<i>&nbsp;</i>The interpreter at the database uses these tags to correctly make the distinction.</td>
      </tr>
      <tr>
        <td><a href="85493314.html">A2:2017-Broken Authentication</a></td>
        <td>
          <p>There are two concerns here:</p>
          <ol>
            <li>An attacker copies or forges the data that the website is using as evidence that an authentic user has logged in.</li>
            <li>An attacker extracts a legitimate copy of that data by trying many combinations of different account names and passwords.</li>
          </ol>
          <p>Example outcome: A user using compromised public wifi inadvertently allows an attacker to access their user account.</p>
        </td>
        <td>
          <p>Optional multi-factor authentication requires more than a password.</p>
          <p>Proof of login is time-limited, transmitted in encrypted form, and tamper-proofed by the server.</p>
          <p>Automated delays on repeated attempts to log-in slow automated attacks to a crawl.</p>
          <p>Mandatory strong passwords. These are checked against known common passwords that would be amongst the first for an attacker to attempt.</p>
        </td>
      </tr>
      <tr>
        <td><a href="85493320.html">A3:2017-Sensitive Data Exposure</a></td>
        <td>
          <p>Web applications often process sensitive data. This might be data that is confidential to a business, or it might be personal identifiable information (perhaps particularly sensitive data such as financial or healthcare data).</p>
          <p>Of special interest are passwords. Many users choose to use the same password to protect their accounts with multiple different organisations. A weakness in the protection of passwords at one server can impact on sites with higher risk profiles.</p>
          <p>There are two concerns here:</p>
          <ol>
            <li>An attacker compromises the network on which the data is communicated back and forth, making copies of the sensitive data.</li>
            <li>An attacker extracts a copy of the database by direct access to the server.</li>
          </ol>
          <p>Example outcome: A user using compromised public wifi inadvertently allows an attacker to access their user account.</p>
        </td>
        <td>
          <p>Communications between browser and website are protected by encryption through HTTPS.</p>
          <p>Optional database encryption mitigates against attackers with direct access to the database files.</p>
          <p>Passwords are given special attention. Rather than store the password itself we store a token derived from the password. The chosen algorithms make it simple to verify a password emits the same token, but exceedingly hard to work backwards from the token to guess the password. In technical terms we use individually salted hashes of the passwords with&nbsp;PBKDF2 encryption.</p>
        </td>
      </tr>
      <tr>
        <td><a href="85493318.html">A4:2017-XML External Entities (XXE)</a></td>
        <td>
          <p>When communicating between browser and web server, the data must be encoded in a format that both ends can interpret. One encoding that has been&nbsp;particularly popular is "XML". However, XML has a feature that effectively instructs the interpreter to reference data elsewhere and continue interpretation. An attacker can send the server XML data purporting to be the data for a filled form.&nbsp;Older, or poorly configured, XML interpreters accept embedded instructions to reference other files without consideration of the possible result.</p>
          <p>Example outcome: The interpretation of the XML data causes the contents of server files to be disclosed. The contents reveal further weaknesses in the server configuration.</p>
        </td>
        <td>The data-transfer architecture is based on JSON rather than XML. This is a simpler encoding format that is not vulnerable to this form of attack.</td>
      </tr>
      <tr>
        <td><a href="85493322.html">A5:2017-Broken Access Control</a></td>
        <td>
          <p>Access control architecture determines which users are permitted to perform which actions.</p>
          <p>There can be a gap between the intended access control and the proper implementation of that access control.</p>
          <p>For instance, access control might erroneously rely on an expectation that links offered to the browser by the server will be the only ones addressed.</p>
          <p>Example outcome: An attacker with a user account is able to access sensitive data belonging to another user.</p>
          <p>Example outcome: An attacker is able to access features intended only for administrative users.</p>
        </td>
        <td>
          <p>The design of access control under BBWT3 denies access to a feature until explicitly coded otherwise. Access control is supported by an architecture assigning users to roles that permit access to specific feature-sets. And, at a finer-level, by supporting access rules that control access to individual resources within a feature-set.</p>
          <p>We provide verifiability of roles-based access control through the "Routes Access" page.</p>
          <p>For administrative access, there is the option to restrict use to certain fixed IP addresses - effectively requiring the administrative user to be at a specific physical location.</p>
        </td>
      </tr>
      <tr>
        <td><a href="85493324.html">A6:2017-Security Misconfiguration</a></td>
        <td>
          <p>Security misconfiguration can happen at any level of the application "stack". A web application's security relies not just on its own code, but also on network services, operating systems, databases, and technical platforms or libraries such as ASP.NET and Angular.</p>
          <p>Of special interest is the security configuration relating to application error messages. Older, or poorly configured, web sites assist the developer in understanding an error by providing valuable diagnostic information on an error to the browser - however, that diagnostic information is also useful to an attacker.</p>
          <p>Example outcome: An attacker is able to query the database directly, bypassing the web site, by manipulating a flaw in network communication protocols.</p>
        </td>
        <td>
          <p>Where acceptable to the customer, privileged access control to the server is limited to system administrators. Expertise in server configuration is built-up through the use of automated configuration tools.</p>
          <p>Error pages don't contain detailed technical information that might reveal configuration details. Instead, this data is internally logged against the error. This takes the user, or the attacker, out of the loop for sensitive information.</p>
        </td>
      </tr>
      <tr>
        <td><a href="85493326.html">A7:2017-Cross-Site Scripting (XSS)</a></td>
        <td>
          <p>An attacker enters hostile data into the website to trick the web server into passing it along to another user's browser.</p>
          <p>XSS flaws occur when the browser's interpreters cannot correctly distinguish which parts of a web server's response are untrusted input data and which parts are a trusted command to the browser.</p>
          <p>Example outcome: An attacker is able to trick an administrative user's browser into executing unwanted instructions, using feature-sets that are intended to be restricted to the administrative user.</p>
          <p>Historical note: Popular sites used to be vulnerable to attacks on browser interpreter issues.&nbsp;Attackers developed special "attack" web-sites that redirected visitors to those popular sites. The redirection was crafted so that the popular site immediately caused the browser to execute the unwanted instructions under the user's account at that popular site. When the vulnerability was discovered, the term "cross-site" was coined. As time passed, the term "cross-site" began to apply to the browser interpreter issue rather than the redirection.</p>
        </td>
        <td>BBWT3 uses the Angular framework, which handles this concern by design. Angular takes a trusted template of HTML and script from the server, and then&nbsp;any further input is interpreted&nbsp;as data&nbsp;for the browser and not&nbsp;as commands for the browser to execute.</td>
      </tr>
      <tr>
        <td><a href="85493328.html">A8:2017-Insecure Deserialisation</a></td>
        <td>
          <p>When communicating between browser and web server, the data must be encoded in a format that both ends can interpret. The act of taking data from an input source such as a network connection is called "deserialisation".</p>
          <p>There are two concerns here:</p>
          <ol>
            <li>When the data format is complex, a weaknesses in the server's interpreters can turn interpretation of hostile data into unintended execution of code on the server.</li>
            <li>Web applications may require the web server send data to the browser to be temporarily stored and returned on the browser's next request. This technique allows the server to avoid otherwise costly look-ups in its own storage. This technique can be used with access control data. If there is an absence of tamper-proofing this can allow an attacker to substitute their own assertions about what they are permitted to access.</li>
          </ol>
          <p>Example outcome: An attacker uploads a 42 kilobyte zip file which an old and vulnerable zip file interpreter deserialises into 4.5 petabytes of data, temporarily overloading the server and preventing legitimate users from accessing the site.</p>
          <p>Example outcome: An attacker is able to access features intended only for administrative users.</p>
        </td>
        <td>
          <p>The data-transfer architecture in BBWT3 is based on JSON. This is a simple encoding format that provides some protection from deserialisation attacks. Further protection is provided by a Data Transfer Object layer which specifies&nbsp;expectations on the incoming data&nbsp;and rejects data that doesn't conform.</p>
          <p>BBWT3 takes the following steps to protect access control tokens: (a) applies encryption to deter attacker's investigation of the token contents on their own machine,&nbsp;(b) provides encryption over the network to deter interception of the token, (c) refuses access control tokens that are old so as to make excessive brute-force computation to break the encryption infeasible&nbsp;(d) provides tamper-proofing through a key and hashing algorithm that demonstrates that the server has "signed" that the data has originated with it, and not elsewhere.</p>
        </td>
      </tr>
      <tr>
        <td><a href="85493330.html">A9:2017-Using Components with Known Vulnerabilities</a></td>
        <td>
          <p>Not only must a server be securely configured, but as weaknesses are discovered by the community, security fixes must be applied in a timely fashion.</p>
          <p>Example outcome: Due to a fault in an older version of a JavaScript library, an attacker is able to use an XSS attack to&nbsp;trick an administrative user's browser into executing unwanted instructions, despite the application's steps to prevent that.</p>
        </td>
        <td>
          <p>Ongoing BBWT3 development stays abreast with the latest versions of components used.</p>
          <p>Where agreed in support plans, Blueberry can provide system administration in keeping servers up to date with the latest security fixes.</p>
          <p>Optionally, we can also provide periodic testing with vulnerability scanning tools such as Acunetix and OpenVAS.</p>
        </td>
      </tr>
      <tr>
        <td colspan="1"><a href="85493332.html">A10:2017-Insufficient Logging &amp; Monitoring</a></td>
        <td colspan="1">
          <p>When many attacks occur, they are not initially noticed.</p>
          <p>There are two concerns here:</p>
          <ol>
            <li>If there is insufficient active monitoring of the web application, then the attacker has plenty of time to refine their attack. Industry surveys suggest that it is far from unusual for an attacker to have six months head start before their attack is discovered. It is only once discovery has occurred that the attacker must begin to work against an active opponent.</li>
            <li>If there is insufficient logging of the web application, then it will be unclear what the attacker has damaged and what data has been compromised. The cost of 'blindly' mitigating against all attacks that could have been performed is substantially higher than the costs of a mitigating against the details of a well-understood attack.</li>
          </ol>
        </td>
        <td colspan="1">
          <p>Optionally, BBWT3 supports both Google's ReCAPTCHA technology,&nbsp;Amazon's AWS Shield Advanced, and similar tools for that mitigate against attacks and importantly notify the application administrators that an attack has been detected.</p>
          <p>BBWT3 uses extensive in-built logging processes delivering logs to an external logserver. Specifically, we use GrayLog for its powerful search features.</p>
          <p>BBWT3 also supports an auditing interface which allows site administrators to view login events and actions taken through the web site.</p>
          <p>&nbsp;</p>
        </td>
      </tr>
    </tbody>
  </table>
</figure>
<p>&nbsp;</p>
<h1>Use of hash of Entity ID&nbsp;</h1>
<h2>Overview</h2>
<p>Many pages pass a record ID within the URL - such as page&nbsp;&nbsp;/users.aspx?id=123 but this exposes the record ID and it is very easy for a hacker to substitute other record ID's here and possibly gain access to additional data.</p>
<p>It has been agreed to encrypt the record ID with a hashing algorithm, The resulting parameter should be partly human readable to aid with debugging.</p>
<p>Note: This is NOT a first line of protection. This feature has only been added as a fallback if the standard user level security checks fail.</p>
<h3>BBWT3</h3>
<p>The final design/implementation is to replace the ID with a two part reference made up of the ID and a hashed value.</p>
<p>Example ... ~/app/demo/orders/edit/1-DA6DEA9A1EA22DA4</p>
<p>The server response to the client will contain two parts - the hashed ID (as above) and just the ID.</p>
<p>In this case, the record ID is 1, and the remaining string is the hash value.<br>Any hacker attempt to get to record ID 2 would need to get the hash correct for that record.<br>The hash is salted using a salt based on the type of object. This prevents a hacker using a known hash for ID 1 on "orders" successfully guessing an unknown hash for ID 1 on "employees".</p>
<p>There will be some record types where the primary key is not a record ID but may be a GUID as in the case of user records.<br>In the case of a GUID, there will be no hashing done to the parameter.</p>
<p>For full details see PTS task&nbsp;<a href="https://ptsa.bbconsult.co.uk/taskEditor?type=3&amp;id=146044">146044</a>&nbsp;(31-01-19)</p>
<p>&nbsp;</p>
<h1>How Security Works&nbsp;</h1>
<h2>Roles Security</h2>
<p>Each controller route may be marked with an “Authorize” attribute.&nbsp;</p>
<p>The code below protects GET api/users/{id}, a route which would return details for a user based on the user id argument passed.<br><strong>api/users/id</strong></p>
<figure class="table">
  <table>
    <tbody>
      <tr>
        <td>
          <p style="text-align:right;">1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</p>
        </td>
        <td><code>[Route("api/users")]</code><br><code>[Authorize]</code><br><code>public</code>&nbsp;<code>class</code>&nbsp;<code>UsersController</code><br><code>{</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [HttpGet, Route("{id}")]</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Authorize(Roles= “Administrator, Manager”)]</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public</code>&nbsp;<code>override</code>&nbsp;<code>async Task&lt;IActionResult&gt; Get(string</code>&nbsp;<code>id, CancellationToken cancellationToken)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;/* ... */</code>&nbsp;<code>}</code><br><code>}</code></td>
      </tr>
    </tbody>
  </table>
</figure>
<p>To interpret the&nbsp;above code:</p>
<ul>
  <li>The attributes above the class apply to all the methods within the class. E.g. lines 1 and 2.</li>
  <li>The attributes above a method apply only to that method. E.g. lines 5 and 6.</li>
  <li>A “blank” Authorize attribute, i.e. [Authorize], requires only that the user must be logged in to access the method. E.g. line 2.</li>
  <li>It's often useful to add a blank&nbsp;[Authorize] to a whole controller.</li>
  <li>Where two Authorize attributes apply then both tests must be passed. Slightly redundant in the example above: line 2 requires the user to be logged in, and line 6 requires&nbsp;<i>both</i>&nbsp;that the user is logged in&nbsp;<i>and</i>&nbsp;has a matching role claim.</li>
</ul>
<p>This attributing technology allows us to read the security by reflection and display it on the “View Route Access” page for the PM or QA to review. This is very helpful for security review.</p>
<h2>Prefer Fewer Arguments</h2>
<p>Consider the first version of the question. The client asks for the names of the groups belonging to the questions for its user. The client knows the questions, so it passes up the ids. This may seem innocuous. BUT, now you have a service that can be called directly, not just by the client code. An attacker that has a login can potentially learn the group names of any question.</p>
<p>Admittedly, this particular example is probably low risk, but it could have been avoided. When this issue was noticed, the PM considered it a problem and asked for a fix. The developer responded that they would add validation. But this sort of failure to add validation is very common. And maintaining validation is troublesome.</p>
<p>A better solution is to rely on the server to know what question groups need to be passed back. After all, the server already knows. Consider the second method interface below. No parameters - no need to remember validation.</p>
<p>When taking this advice it is important to remember that there&nbsp;<i>is</i>&nbsp;a counter-argument that will apply sometimes. We should prefer our services to be RESTful - the client should not try to "offload" session status into the server to avoid passing a parameter. If this was a case of looking up the names of the groups for just page 17 of a grid, then the server has no business knowing about page 17. I'd still argue strongly that the first method was the wrong solution to solve that problem - if the group names are of interest, then we should typically send them&nbsp;<i>with</i>&nbsp;the questions.<br><strong>The risks of arguments</strong></p>
<figure class="table">
  <table>
    <tbody>
      <tr>
        <td><code>public</code>&nbsp;<code>async Task&lt;List&lt;QuestionGroupDTO&gt;&gt; GetQuestionGroupsForQuestions(List&lt;int?&gt; questions)</code><br>&nbsp;<br>&nbsp;<br><code>public</code>&nbsp;<code>async Task&lt;List&lt;QuestionGroupDTO&gt;&gt; GetQuestionGroupsForMyQuestions()</code></td>
      </tr>
    </tbody>
  </table>
</figure>
<h2>Prefer Roles Security</h2>
<p>It is easier to be correctly confident about roles security than resource security. It's simpler to read, simpler to understand, and simpler to test.</p>
<p>Often, you can nudge an API from resource security to role security. You can often do this whenever a user can only access a&nbsp;<i>single</i>&nbsp;item of that resource.</p>
<p>For example: there may be a rule that anyone should be allowed to see their own user details, but Administrators are allowed to see everyone’s. Or&nbsp;a rule that anyone should be allowed to see their own company's contact details, and that each user belongs to just one company, but Administrators are allowed to see everyone’s company contact details.&nbsp;</p>
<p>There are two ways of implementing the user details rule:</p>
<ul>
  <li>The difficult way: You write one method, accessible to everyone, in which resource based security checks (a) whether you are an administrator, (b) failing that, whether the id argument matches the user id of the current user.</li>
  <li>The easy way: You write two methods. One method for the administrator that has role security on it, and takes a parameter. A second method is accessible to all, but instead of taking a parameter, it returns the details for the&nbsp;<i>current</i>&nbsp;user. See the code below.<br><br>&nbsp;</li>
</ul>
<p><br><strong>api/users/current</strong></p>
<figure class="table">
  <table>
    <tbody>
      <tr>
        <td><code>[Route("api/users")]</code><br><code>[Authorize]</code><br><code>public</code>&nbsp;<code>class</code>&nbsp;<code>UsersController</code><br><code>{</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [HttpGet, Route("{id}")]</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [Authorize(Roles= “Administrator”)]</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public</code>&nbsp;<code>override</code>&nbsp;<code>async Task&lt;IActionResult&gt; Get(string</code>&nbsp;<code>id, CancellationToken cancellationToken)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;/* ... */</code>&nbsp;<code>}</code><br>&nbsp;<br>&nbsp;<br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [HttpGet, Route("current")]</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public</code>&nbsp;<code>override</code>&nbsp;<code>async Task&lt;IActionResult&gt; Get(CancellationToken cancellationToken)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Get the user's id - instead of accepting it as a parameter</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Call the above method passing the id: return Get(id, cancellationToken)</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // ...</code><br><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</code><br><code>}</code></td>
      </tr>
    </tbody>
  </table>
</figure>
<h2>Resource Security</h2>
<p>Not everything can be nudged into roles security. Resource security is used for more complex rules and differs from project to project.&nbsp;</p>
<p>Because resource security needs to load the details about the requested resource, it has to&nbsp;occur within<i>&nbsp;</i>the controller's method body. But, we can typically inject that code into the method body.</p>
<p>For resource security, you will need a custom “handler” for the controller.</p>
<p>Often handlers will share code. A handler should mostly be a “routing mechanism” finding the data for a shared test. The shared test might be as simple as "is the group that 'this'&nbsp;<i>resource</i>&nbsp;belongs to, the same as the group that 'this'&nbsp;<i>user</i>&nbsp;belongs to". The non-shared code is responsible for navigating the data model to find out which group the resource belongs to.</p>
<p>It would be nice if we could should show the names of the shared tests being applied for an API at the View Routes Access page. (31-01-19<a href="https://pts.bbconsult.co.uk/taskEditor?id=158253">&nbsp;#158253</a>).</p>
<p>Reference URLs:</p>
<ul>
  <li>Demonstration:&nbsp;<a href="https://bbwt3-test-1.blueberrycf.com/app/demo/security/readmefirst">https://bbwt3-test-1.blueberrycf.com/app/demo/security/readmefirst</a></li>
  <li>Overview:&nbsp;<a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/resourcebased?tabs=aspnetcore2x">https://docs.microsoft.com/en-us/aspnet/core/security/authorization/resourcebased?tabs=aspnetcore2x</a></li>
</ul>
<p>Authorization Handler:&nbsp;<a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies#security-authorization-policies-based-authorization-handler">https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies#security-authorization-policies-based-authorization-handler</a></p>
<h2>Example code in BBWT3 demo:&nbsp;</h2>
<ul>
  <li>AccessibleToGroupAuthorizationHandler.cs</li>
  <li>AuthorizationExtensions.cs</li>
  <li>GroupsAuthorizationHandler.cs</li>
  <li>SecurityTestController.cs<br><br>&nbsp;</li>
</ul>
<h2>Complex Example for Groups</h2>
<p>For VME we have an “Orders” or “Job Request” Controller. For some of its Order API calls, we want to restrict the using roles to: Customer Financial Controller, Customer Vehicle Owner, Customer Dispatcher, VME Account Administrator, VME Account Manager, VME Network Manager, VME Operations Agent, VME Dispatcher, VME Customer Liaison. But not only do we require the right roles, we also require that the customers don’t access data belonging to other customers, or other departments, or other teams within the department.</p>
<p>With api/orders/copy/{orderId} we can't nudge to role security - multiple orders belong to a customer user, not just one.</p>
<p>We would write an AuthorizationHandler for Orders. Several Order API calls will make use of it. It:</p>
<ul>
  <li>checks if the user has role claims to any of the several defined VME roles – and if so, returns success,</li>
  <li>failing that,<ul>
      <li>checks if the user has role claims to the several defined customer roles that may sometimes access orders – and if not, returns failure</li>
      <li>if the user&nbsp;<i>is</i>&nbsp;in one of those customer roles, then<ul>
          <li>In the complex case of the VME application, it needs to navigate the data model to find order.customerid and order.job.….teamId and order.job…..departmentId. The ellipses conceal the details of the navigation through the data model.</li>
          <li>It passes that data to a test in shared code, along with the user.</li>
          <li>In the complex case of the VME application, the shared code tests that the user’s customer claim exists AND that the passed customerId matches the claim AND (if&nbsp;a user has a team claim, then that must match), AND (if&nbsp;a user has a department claim then that must match) - and only then returns success</li>
          <li>Failing that, it returns failure</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p>&nbsp;</p>
<h2>Complex Example for Changing State</h2>
<p>If you want to tests such as “if entity Y&nbsp;<i><strong>currently</strong></i>&nbsp;passes a test with respect to the calling user Z”, then you’d also include that code in the Authorization Handler. VME’s existing capacity test is an example of such a test. If the current date is after the "On Hold Date" for the order but before the "Buy It Now Date", and the user is part of a supplier who “has similar jobs”, then they are permitted to see the order.</p>
<p>It is preferable that the screens are designed so that such tests are not performed frequently, but this will not always be possible.</p>
<h2>Resource Security and Lists&nbsp;</h2>
<p>If we're preventing a user from seeing "api/documents/1" then we usually won't want document 1 to appear in the list "api/documents".</p>
<p>We could rely on developers to remember to filter their lists, but the more complex the API, the more difficult it is to remember all the places where a list needs filtering. It is much safer to perform the filtering at a "lower" level. The DBContext is a great place to provide that filtering.</p>
<p>The code below ensures that when a LINQ query references the model item “customer”, only those customers that have the same tenant id as the connection are returned.<br><strong>Example List Filtering</strong></p>
<figure class="table">
  <table>
    <tbody>
      <tr>
        <td><code>public</code>&nbsp;<code>MyDbContext(Guid tenantId,&nbsp;string</code>&nbsp;<code>connection) {</code><br><code>&nbsp;&nbsp;&nbsp; // … store the parameters in “this” then …</code><br><code>&nbsp;&nbsp;&nbsp; this.Filter&lt;Customer&gt;(x =&gt; x.Where(q =&gt; q.TenantId ==&nbsp;this.tenantId));</code><br><code>&nbsp;&nbsp;&nbsp; // ...</code><br><code>}</code></td>
      </tr>
    </tbody>
  </table>
</figure>
<p>Not shown in the example - you should call the same shared test code as in the basic resource security.&nbsp;&nbsp;It would be nice if (a) there was a way to do that nicely and (b) demonstrate that it has been done.</p>
<h2>Reference URLs</h2>
<ul>
  <li>Demonstration:&nbsp;<a href="https://bbwt3-test-1.blueberrycf.com/app/demo/security/readmefirst">https://bbwt3-test-1.blueberrycf.com/app/demo/security/readmefirst</a></li>
  <li>Technique:&nbsp;<a href="https://codeopinion.com/ef-core-multi-tenancy-query-filter/">https://codeopinion.com/ef-core-multi-tenancy-query-filter/</a></li>
  <li>Required package:&nbsp;<a href="https://github.com/zzzprojects/EntityFramework-Plus">https://github.com/zzzprojects/EntityFramework-Plus</a></li>
</ul>
<h2>Visibility at Client</h2>
<p>Above, we've spoken about how the APIs are secured. To hide pages and menu items, the client needs to know which pages and menu items it has access to. Use RoutesService.cs for this.&nbsp;</p>
<p>It would be nice if this wasn't necessary. It be would be nice if we could infer what should be hidden from the API used at the page. E.g. the page uses POST api/orders which is restricted to the OrderCreators role implies&nbsp;the page should be hidden to everyone but OrderCreators. But this would require more research and development than we have time for currently. Potential solutions need to consider how we detect pages that call services only conditionally, e.g. the same page is shown to OrderViewers too, but with the creation controls hidden and hence POST api/orders won't be called.</p>
<p>Sometimes we want to hide controls based on security.&nbsp;An example of what we do today is the use of CanImpersonate and the hiding of the Impersonate button depending on a rule. Login at&nbsp;<a href="https://bbwt3-test-1.blueberrycf.com/app/edituser/c20bfdd4-07f7-4f56-9df8-1643360b9cae">https://bbwt3-test-1.blueberrycf.com/app/edituser/c20bfdd4-07f7-4f56-9df8-1643360b9cae</a>&nbsp;as an admin to see the Impersonate button.&nbsp;It would be nice if we created a bit of architecture to allow for asking whether a call to a particular API would be rejected (for a given resource).&nbsp;</p>
<h2>Security at Database</h2>
<p>Currently BBWT database security is typically limited to using one DB login only. With all users of the site effectively having equal access to the database, mitigated only by the Web API calls that they have permission to use.&nbsp;It would be nice if we created a bit of architecture to allow mapping of BBWT roles or users into the DB security, so that if a Web API call provides insufficient protection, the DB itself can reject a request. This would give additional protection against SQL injection attacks, or overly permissive user-reporting features.&nbsp;</p>
<h2>Security of Site Admin Functionality</h2>
<p>Currently BBWT systems allow access to site admin and configuration features from any IP address and at the same URL as the rest of the site.&nbsp; &nbsp;It would be nice if this access was narrowed down further, by e.g. insisting that site admin features only unlock upon access over a VPN, or with Two Factor Authentication.&nbsp;(31-01-19&nbsp;<a href="https://ptsa.bbconsult.co.uk/taskEditor?type=3&amp;id=146376&amp;returnUrl=https%3A%2F%2Fptsa.bbconsult.co.uk%2F%2Ftasks">#146376</a>).</p>
<p>&nbsp;</p>
