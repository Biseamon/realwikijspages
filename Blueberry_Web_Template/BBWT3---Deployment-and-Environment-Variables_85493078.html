<!--
title: BBWT3---Deployment-and-Environment-Variables_85493078
description: 
published: true
date: 2020-12-02T11:55:20.746Z
tags: 
editor: undefined
dateCreated: 2020-11-27T11:03:46.141Z
-->

<!DOCTYPE html>
<html>
    <head>
        <title>Blueberry Group : BBWT3 - Deployment and Environment Variables</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">Blueberry Group</a></span>
                            </li>
                                                    <li>
                                <span><a href="Blueberry-Web-Template_85492520.html">Blueberry Web Template</a></span>
                            </li>
                                                    <li>
                                <span><a href="BBWT3_85492530.html">BBWT3</a></span>
                            </li>
                                                    <li>
                                <span><a href="BBWT3---Build-Process-and-CI_85493059.html">BBWT3 - Build Process and CI</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            Blueberry Group : BBWT3 - Deployment and Environment Variables
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
        
            Created by <span class='author'> Jason Cozza</span> on Sep 21, 2020
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <h1 id="BBWT3-DeploymentandEnvironmentVariables-Overview">Overview</h1><p>In ASP.NET core you can have multiple configuration providers which take configuration from different sources including json files and environment variables. The primary json file that it takes base configuration data from is the <strong>appsettings.json</strong> file located in: ./src/BBWT3.Web. It doesn’t matter what values are defined in there but what does matter is the order of loading.</p><p>During start-up, BBWT3 will look for specific files in a specific order. The first is <strong>appsettings.json</strong> in the application root. Then it will concatenate the current environment name with <strong>appsettings.json </strong>in the form <strong>appsettings.$Environment.json</strong>. The settings defined in this file will take priority over those defined in <strong>appsettings.json</strong>.</p><p>ASP.NET core recognises three values for environment names:</p><ul><li>Development.</li><li>Staging.</li><li>Production.</li></ul><p>These can be referenced as symbols in your code, see <a class="external-link" href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.hosting.ihostingenvironment.environmentname?view=aspnetcore-2.2" rel="nofollow">IHostingEnvironment</a>.</p><p>When running locally, developers will want to create a copy of <strong>appsettings.Development.template.json </strong>as <strong>appsettings.Development.json</strong>.</p><p>BBWT3 currently has three common ways of deployment which we will now look at.</p><h1 id="BBWT3-DeploymentandEnvironmentVariables-Stand-aloneServerDeployment">Stand-alone Server Deployment</h1><p>In production we would set it to production, or test1 or whatever were using at the time for that project. Then if we needed to we would create on the server a file with database settings etc. which is only accessible on that server. Depending on what the set up is we may update that file with different methods:</p><ul><li><p>We could remote connect to it and update the file manually.</p></li><li><p>We could update it through Amazon SSM.</p></li><li><p>Or update it through remote management tools - SSH/RDP.</p></li></ul><p>We don't want to store secrets in GitLab in the appsettings file. If we were to store secrets in GitLab we would generate an appsettings.production file as part of CI and bundle that into the app and then deploy it. This method has been used in the past.</p><p>Things like database type, log levels, log level base, log providers, base log outputs, those wouldn't necessarily be a secret. You might always want to log to console, but not necessarily log to disk. You can inference that in the repository directly – if you want to set a base for the project, that's what we refer to as the appsettings.json file. It is the base template for the project that developers and deployer’s can build upon.</p><h2 style="margin-left: 30.0px;" id="BBWT3-DeploymentandEnvironmentVariables-KeepingThingsHiddeninGitLab">Keeping Things Hidden in GitLab</h2><p style="margin-left: 30.0px;">We do have ways of keeping things hidden in GitLab. Only maintainers (project managers) can access those, and the server projects have certain CI scripts which can generate a production JSON file to be deployed to the single server setup. GitLab has a mechanism for doing secrets, which has been used on single servers in the past, but it is a little bit more difficult to get to because it is inside GitLab.</p><p style="margin-left: 30.0px;">Maintainers have access to a script that can create JSON files from GitLab secrets – maintainers have access to a hidden page in GitLab for the project (in GitLab inside repository on the left hand side you will see settings, inside there is a subgroup called CI / CD. Inside that page is a secret variables drop down that you can expand, and input key value pairs and those are available at build time. Only the maintainer can update and see those values.</p><p style="margin-left: 30.0px;">That is part of the deployment through the GitLab CI <strong>OWEL(?)</strong> file which has the script to pull those values, transform them into a JSON structure, and write it to a file as part of the deployment. The issue with scaling is that for every key that you add to GitLab, you have to explicitly reference that key in GitLab CI, so you would need to make an update to that file.</p><p style="margin-left: 30.0px;">It is possible to do a “get *.*” you could get everything prefixed with “CI_” or a specific prefix we specify which we could do some pattern matching with to make it more scalable. This method is relatively secure based on the assumption that the GitLab secret has been saved in a secure way, with the additional security of that it is only accessible to maintainers.</p><p style="margin-left: 30.0px;">The primary use we have for doing this is for the database connection strings. So if a project manager wanted to change a database connection string for whatever reason, they could go into the GUI update it, and push it out and it will work.</p><p style="margin-left: 30.0px;">The variables are for the project and not for a particular deployment environment and so we have used a naming convention to get around that.</p><p style="margin-left: 30.0px;">There are two methods of doing it, the first would be just to put them straight into the source code. For very unsecure settings they can go straight into an appsettings.json file or an appsettings.production file in the source code and that will go through. The second is for secrets, you can put them into GitLab instead of into CI. These two methods are what we use combined for our single server case.</p><h2 style="margin-left: 30.0px;" id="BBWT3-DeploymentandEnvironmentVariables-Branches">Branches</h2><p style="margin-left: 30.0px;">On a normal stand-alone server we would have a branch for live, and one for test. You would have the main development branch, that is then merged in to one for test, which would go to your test server, then a live one which would be the master branch. It was previously agreed that the master would be the live. The point about this is that you can put an appsettings.json file into each branch so that when they are deployed to one system such as test, it will get the test settings file, and if you deploy it somewhere else such as live, it will get the live appsettings.json file.</p><h1 id="BBWT3-DeploymentandEnvironmentVariables-AWSElasticBeanstalkDeployment">AWS Elastic Beanstalk Deployment</h1><p>Elastic Beanstalk is a way for Amazon to take your deployment package and put it onto a server or a set of servers, it starts by putting it into an s3 bucket. Your deployment server polls that bucket and deploying is based on a certain strategy; e.g. all in one or release across servers etc.</p><p>The important thing is that they take away all that machinery out of your hands and deploy it for you and give you a status report of the deployment. It also allows them to store key value pairs in Amazon encrypted, to then use in the environment of the application. The way they do this is by writing a file as part of the deployment to the disk which your app will then need to pick up.</p><p>Historically these are normally injected into the environment process. In the case of dotnet core there is a long-standing bug where this doesn't happen (existed since 2016). So a work around has been implemented in BBWT3 where we manually read the file that they write to disk, and then we read it with a configuration provider and that adds it to a set of values and we have a middleware called “Elastic Beanstalk Provider” within the BBWT3 middleware which does this. The path is located in BBWT3’s provider, so you can find it quite easily.</p><p>It only exists on the server and is rewritten on every release we do through Elastic Beanstalk, but it comes from the GUI you use on Amazon.<br/>This however is simply an implementation detail, and a developer won’t really need to worry about this.</p><p>The reason we do this is so we can take advantage of the GUI Amazon provides, which allows people a very user friendly way of defining these user variables without having to think about it. They just press a button to push it out and Elastic Beanstalk handles getting it on to the server.</p><p>What you put into the Amazon variables is the same as what you would put in the GitLab secret variables as described in the above stand-alone server deployment section.</p><h2 style="margin-left: 30.0px;" id="BBWT3-DeploymentandEnvironmentVariables-AdvantagesofUsingAmazonElasticBeanstalkInsteadofGitLab">Advantages of Using Amazon Elastic Beanstalk Instead of GitLab</h2><p style="margin-left: 30.0px;">We use Elastic Beanstalk variables as it is easier to just update the configuration. If you were to use GitLab, you would have to do another deployment and plan your deployment so that it doesn't collide with anyone else's. If you change the variables in Amazon it reboots the process not the server, so it is quicker than GitLab; where you would have to do a whole deployment cycle.</p><p style="margin-left: 30.0px;">Another advantage of using Amazon is its IAM (Identity Access Management) approach. The advantage to doing changes through Amazon’s IAM over GitLab is that it has tracking – GitLab does not. Amazon IAM is accessible for project managers. We can create a new group in IAM which gives the project manager the requisite access to this page for their projects. Then they can go in and tinker with it. Tracking can be achieved with the use of CloudTrail, an admin can see if you made “x” change. But there is no revision history. However this is not usually an issue as secrets don’t usually change.</p><p style="margin-left: 30.0px;">The proper way is to use the Amazon parameter store and then having the application read in through Amazon’s API’s from parameter store which is Amazon's solution for it. So we could write a middleware wrapping around the parameter store and then we give a prefix for each application deployment – e.g. BBWT3-test1/key which would allow us to partition the parameter store for each application and gives a fully tracked managed way of doing it with revision history for each parameter.</p><p style="margin-left: 30.0px;">It is possible to make that as familiar as possible to the user by including it within BBWT3 itself, however you would need to make it able to write back to the correct application. If we push the configuration back into the Amazon parameter store, and we use the API’s of the Amazon parameter store, we can save them in there and it will be central and will work for every Amazon deployment that we do. However like this it will not work on Azure. It could be made to work on Azure however it would entail writing a middleware that talks to both. Which probably is the best way to do this.</p><p style="margin-left: 30.0px;">Currently we don’t have a mechanism for connecting the GitLab variables to the parameter store, we would need a separate application to sync those.</p><h1 id="BBWT3-DeploymentandEnvironmentVariables-ElasticContainerServiceDeployment">Elastic Container Service Deployment</h1><p>Elastic container service is a proprietary Amazon service which is their way of doing container scheduling, with its own way of managing its secrets and environment variables. Its main advantage is that it gives improved security.</p><p>The way it works is you have a container, ie. BBWT3 Then you create a task for that container, which specifies how it should run, how many resources It should take and more importantly the configuration/environment variables which should be attached to that container.</p><p>You create a new task version every time you wish to update the container software with variables, then you push that out to a service running on your cluster. The way it was done in VME was you had a 1 to 1 relationship without multiple services, you had the 1 service on the 1 cluster with the 1 task. But it can be mixed up as much as needed but that's how it was done for simplicity.</p><p>It is another user interface where you define environment variables, and those environment variables are made available to the process as environment variables without any middleware. It is injected correctly, unlike with Elastic Beanstalk.</p><h1 id="BBWT3-DeploymentandEnvironmentVariables-ThePreferredMethod">The Preferred Method</h1><p>The preferred method is to use the Amazon Parameter Store which will work across every case.</p><p>Alternatively we can use Elastic Beanstalk.<br/>Elastic beanstalk is now available for use on single servers,  we could integrate Cloud Machine Manager (CMM) and this would give us an easier route for deployment.</p><p>The load balancer is optional so the main benefit from this is the deployment strategy - you can upload a zip file, and it goes and deploys it. Which for Windows servers is a better alternative than having GitLab go and open ssh to drop the files off. It handles the Windows server use case very well.</p><p>The work around for single server without using Elastic Beanstalk was that GitLab creates a zip file ssh connection to the server uploads the zip file, and write our own deployment scripts to replace the IIS folder. Using this method you would not be able to do a soft deployment (updating the code without taking the system down) as can be done with Elastic Beanstalk.</p>
                    </div>

                    
                 
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Nov 27, 2020 10:56</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
