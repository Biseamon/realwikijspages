<!DOCTYPE html>
<html>
    <head>
        <title>Blueberry Group : BBWT3 - How Security Works</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">Blueberry Group</a></span>
                            </li>
                                                    <li>
                                <span><a href="Blueberry-Web-Template_85492520.html">Blueberry Web Template</a></span>
                            </li>
                                                    <li>
                                <span><a href="BBWT3_85492530.html">BBWT3</a></span>
                            </li>
                                                    <li>
                                <span><a href="BBWT3---Security_85493287.html">BBWT3 - Security</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            Blueberry Group : BBWT3 - How Security Works
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
        
            Created by <span class='author'> Jason Cozza</span> on Sep 21, 2020
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <div class="confluence-information-macro confluence-information-macro-information"><span class="aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon"></span><div class="confluence-information-macro-body">Please read <a href="BBWT3---Security_85493287.html">BBWT3 - Security</a></div></div><h1 id="BBWT3-HowSecurityWorks-RolesSecurity">Roles Security</h1><p>Each controller route may be marked with an “Authorize” attribute. </p><p>The code below protects GET api/users/{id}, a route which would return details for a user based on the user id argument passed.<br/><strong>api/users/id</strong></p><div class="table-wrap"><table class="confluenceTable"><colgroup><col/><col/></colgroup><tbody><tr><td class="confluenceTd"><p style="text-align: right;">1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9</p></td><td class="confluenceTd"><p><code>[Route(</code><code>&quot;api/users&quot;</code><code>)]</code><br/><code>[Authorize]</code><br/><code>public</code> <code>class</code> <code>UsersController</code><br/><code>{</code><br/><code>        </code><code>[HttpGet, Route(</code><code>&quot;{id}&quot;</code><code>)]</code><br/><code>        </code><code>[Authorize(Roles= “Administrator, Manager”)]</code><br/><code>        </code><code>public</code> <code>override</code> <code>async Task&lt;IActionResult&gt; Get(</code><code>string</code> <code>id, CancellationToken cancellationToken)</code><br/><code>        </code><code>{ </code><code>/* ... */</code> <code>}</code><br/><code>}</code></p></td></tr></tbody></table></div><p>To interpret the above code:</p><ul><li>The attributes above the class apply to all the methods within the class. E.g. lines 1 and 2. </li><li>The attributes above a method apply only to that method. E.g. lines 5 and 6.</li><li>A “blank” Authorize attribute, i.e. [Authorize], requires only that the user must be logged in to access the method. E.g. line 2.</li><li>It's often useful to add a blank [Authorize] to a whole controller.</li><li>Where two Authorize attributes apply then both tests must be passed. Slightly redundant in the example above: line 2 requires the user to be logged in, and line 6 requires <em>both</em> that the user is logged in <em>and</em> has a matching role claim.</li></ul><p>This attributing technology allows us to read the security by reflection and display it on the “View Route Access” page for the PM or QA to review. This is very helpful for security review.</p><h1 id="BBWT3-HowSecurityWorks-PreferFewerArguments">Prefer Fewer Arguments</h1><p>Consider the first version of the question. The client asks for the names of the groups belonging to the questions for its user. The client knows the questions, so it passes up the ids. This may seem innocuous. BUT, now you have a service that can be called directly, not just by the client code. An attacker that has a login can potentially learn the group names of any question.</p><p>Admittedly, this particular example is probably low risk, but it could have been avoided. When this issue was noticed, the PM considered it a problem and asked for a fix. The developer responded that they would add validation. But this sort of failure to add validation is very common. And maintaining validation is troublesome.</p><p>A better solution is to rely on the server to know what question groups need to be passed back. After all, the server already knows. Consider the second method interface below. No parameters - no need to remember validation.</p><p>When taking this advice it is important to remember that there <em>is</em> a counter-argument that will apply sometimes. We should prefer our services to be RESTful - the client should not try to &quot;offload&quot; session status into the server to avoid passing a parameter. If this was a case of looking up the names of the groups for just page 17 of a grid, then the server has no business knowing about page 17. I'd still argue strongly that the first method was the wrong solution to solve that problem - if the group names are of interest, then we should typically send them <em>with</em> the questions.<br/><strong>The risks of arguments</strong></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><code>public</code> <code>async Task&lt;List&lt;QuestionGroupDTO&gt;&gt; GetQuestionGroupsForQuestions(List&lt;</code><code>int</code><code>?&gt; questions)</code><br/> <br/> <br/><code>public</code> <code>async Task&lt;List&lt;QuestionGroupDTO&gt;&gt; GetQuestionGroupsForMyQuestions()</code></p></td></tr></tbody></table></div><h1 id="BBWT3-HowSecurityWorks-PreferRolesSecurity"><span style="color: rgb(0,51,102);">Prefer Roles Security</span></h1><p>It is easier to be correctly confident about roles security than resource security. It's simpler to read, simpler to understand, and simpler to test.</p><p>Often, you can nudge an API from resource security to role security. You can often do this whenever a user can only access a <em>single</em> item of that resource.</p><p>For example: there may be a rule that anyone should be allowed to see their own user details, but Administrators are allowed to see everyone’s. Or a rule that anyone should be allowed to see their own company's contact details, and that each user belongs to just one company, but Administrators are allowed to see everyone’s company contact details. </p><p>There are two ways of implementing the user details rule:</p><ul><li>The difficult way: You write one method, accessible to everyone, in which resource based security checks (a) whether you are an administrator, (b) failing that, whether the id argument matches the user id of the current user.</li><li>The easy way: You write two methods. One method for the administrator that has role security on it, and takes a parameter. A second method is accessible to all, but instead of taking a parameter, it returns the details for the <em>current</em> user. See the code below.<br/><br/></li></ul><p><br/><strong>api/users/current</strong></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><code>[Route(</code><code>&quot;api/users&quot;</code><code>)]</code><br/><code>[Authorize]</code><br/><code>public</code> <code>class</code> <code>UsersController</code><br/><code>{</code><br/><code>        </code><code>[HttpGet, Route(</code><code>&quot;{id}&quot;</code><code>)]</code><br/><code>        </code><code>[Authorize(Roles= “Administrator”)]</code><br/><code>        </code><code>public</code> <code>override</code> <code>async Task&lt;IActionResult&gt; Get(</code><code>string</code> <code>id, CancellationToken cancellationToken)</code><br/><code>        </code><code>{ </code><code>/* ... */</code> <code>}</code><br/> <br/> <br/><code>        </code><code>[HttpGet, Route(</code><code>&quot;current&quot;</code><code>)]</code><br/><code>        </code><code>public</code> <code>override</code> <code>async Task&lt;IActionResult&gt; Get(CancellationToken cancellationToken)</code><br/><code>        </code><code>{</code><br/><code>            </code><code>// Get the user's id - instead of accepting it as a parameter</code><br/><code>            </code><code>// Call the above method passing the id: return Get(id, cancellationToken)</code><br/><code>            </code><code>// ...</code><br/><code>        </code><code>}</code><br/><code>}</code></p></td></tr></tbody></table></div><h1 id="BBWT3-HowSecurityWorks-ResourceSecurity"><span style="color: rgb(0,51,102);">Resource Security</span></h1><p>Not everything can be nudged into roles security. Resource security is used for more complex rules and differs from project to project. </p><p>Because resource security needs to load the details about the requested resource, it has to occur within<em> </em>the controller's method body. But, we can typically inject that code into the method body.</p><p>For resource security, you will need a custom “handler” for the controller.</p><p>Often handlers will share code. A handler should mostly be a “routing mechanism” finding the data for a shared test. The shared test might be as simple as &quot;is the group that 'this' <em>resource</em> belongs to, the same as the group that 'this' <em>user</em> belongs to&quot;. The non-shared code is responsible for navigating the data model to find out which group the resource belongs to.</p><p>It would be nice if we could should show the names of the shared tests being applied for an API at the View Routes Access page. (31-01-19<a class="external-link" href="https://pts.bbconsult.co.uk/taskEditor?id=158253" rel="nofollow"> #158253</a>).</p><p>Reference URLs:</p><ul><li>Demonstration: <a class="external-link" href="https://bbwt3-test-1.blueberrycf.com/app/demo/security/readmefirst" rel="nofollow">https://bbwt3-test-1.blueberrycf.com/app/demo/security/readmefirst</a></li><li>Overview: <a class="external-link" href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/resourcebased?tabs=aspnetcore2x" rel="nofollow">https://docs.microsoft.com/en-us/aspnet/core/security/authorization/resourcebased?tabs=aspnetcore2x</a></li><li><p class="pts75">Authorization Handler: <a class="external-link" href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies#security-authorization-policies-based-authorization-handler" rel="nofollow">https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies#security-authorization-policies-based-authorization-handler</a></p></li></ul><p class="pts75">Example code in BBWT3 demo: </p><ul><li class="pts75"><span style="color: rgb(0,51,102);">AccessibleToGroupAuthorizationHandler.cs</span></li><li class="pts75">AuthorizationExtensions.cs</li><li class="pts75">GroupsAuthorizationHandler.cs</li><li class="pts75"><span style="color: rgb(0,51,102);">SecurityTestController.cs</span><br/><br/></li></ul><p class="title">Complex Example for Groups</p><p>For VME we have an “Orders” or “Job Request” Controller. For some of its Order API calls, we want to restrict the using roles to: Customer Financial Controller, Customer Vehicle Owner, Customer Dispatcher, VME Account Administrator, VME Account Manager, VME Network Manager, VME Operations Agent, VME Dispatcher, VME Customer Liaison. But not only do we require the right roles, we also require that the customers don’t access data belonging to other customers, or other departments, or other teams within the department.</p><p>With api/orders/copy/{orderId} we can't nudge to role security - multiple orders belong to a customer user, not just one.</p><p>We would write an AuthorizationHandler for Orders. Several Order API calls will make use of it. It:</p><ul><li>checks if the user has role claims to any of the several defined VME roles – and if so, returns success,</li><li class="pts75">failing that,<ul><li class="pts75">checks if the user has role claims to the several defined customer roles that may sometimes access orders – and if not, returns failure</li><li class="pts75">if the user <em>is</em> in one of those customer roles, then<ul><li class="pts75">In the complex case of the VME application, it needs to navigate the data model to find order.customerid and order.job.….teamId and order.job…..departmentId. The ellipses conceal the details of the navigation through the data model.</li><li class="pts75">It passes that data to a test in shared code, along with the user.</li><li class="pts75">In the complex case of the VME application, the shared code tests that the user’s customer claim exists AND that the passed customerId matches the claim AND (if a user has a team claim, then that must match), AND (if a user has a department claim then that must match) - and only then returns success</li><li class="pts75">Failing that, it returns failure</li></ul></li></ul></li></ul><p><br/></p><p class="title">Complex Example for Changing State</p><p>If you want to tests such as “if entity Y <strong><em>currently</em></strong> passes a test with respect to the calling user Z”, then you’d also include that code in the Authorization Handler. VME’s existing capacity test is an example of such a test. If the current date is after the &quot;On Hold Date&quot; for the order but before the &quot;Buy It Now Date&quot;, and the user is part of a supplier who “has similar jobs”, then they are permitted to see the order.</p><p>It is preferable that the screens are designed so that such tests are not performed frequently, but this will not always be possible.</p><h1 id="BBWT3-HowSecurityWorks-ResourceSecurityandLists">Resource Security and Lists<u><br/></u></h1><p>If we're preventing a user from seeing &quot;api/documents/1&quot; then we usually won't want document 1 to appear in the list &quot;api/documents&quot;.</p><p>We could rely on developers to remember to filter their lists, but the more complex the API, the more difficult it is to remember all the places where a list needs filtering. It is much safer to perform the filtering at a &quot;lower&quot; level. The DBContext is a great place to provide that filtering.</p><p>The code below ensures that when a LINQ query references the model item “customer”, only those customers that have the same tenant id as the connection are returned.<br/><strong>Example List Filtering</strong></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><code>public</code> <code>MyDbContext(Guid tenantId, </code><code>string</code> <code>connection) {</code><br/><code>    </code><code>// … store the parameters in “this” then …</code><br/><code>    </code><code>this</code><code>.Filter&lt;Customer&gt;(x =&gt; x.Where(q =&gt; q.TenantId == </code><code>this</code><code>.tenantId));</code><br/><code>    </code><code>// ...</code><br/><code>}</code></p></td></tr></tbody></table></div><p>Not shown in the example - you should call the same shared test code as in the basic resource security.  It would be nice if (a) there was a way to do that nicely and (b) demonstrate that it has been done.</p><h2 id="BBWT3-HowSecurityWorks-ReferenceURLs">Reference URLs</h2><ul><li>Demonstration: <a class="external-link" href="https://bbwt3-test-1.blueberrycf.com/app/demo/security/readmefirst" rel="nofollow">https://bbwt3-test-1.blueberrycf.com/app/demo/security/readmefirst</a></li><li>Technique: <a class="external-link" href="https://codeopinion.com/ef-core-multi-tenancy-query-filter/" rel="nofollow">https://codeopinion.com/ef-core-multi-tenancy-query-filter/</a></li><li>Required package: <a class="external-link" href="https://github.com/zzzprojects/EntityFramework-Plus" rel="nofollow">https://github.com/zzzprojects/EntityFramework-Plus</a> </li></ul><h1 id="BBWT3-HowSecurityWorks-VisibilityatClient">Visibility at Client</h1><p>Above, we've spoken about how the APIs are secured. To hide pages and menu items, the client needs to know which pages and menu items it has access to. Use RoutesService.cs for this. </p><p>It would be nice if this wasn't necessary. It be would be nice if we could infer what should be hidden from the API used at the page. E.g. the page uses POST api/orders which is restricted to the OrderCreators role implies the page should be hidden to everyone but OrderCreators. But this would require more research and development than we have time for currently. Potential solutions need to consider how we detect pages that call services only conditionally, e.g. the same page is shown to OrderViewers too, but with the creation controls hidden and hence POST api/orders won't be called.</p><p>Sometimes we want to hide controls based on security. An example of what we do today is the use of CanImpersonate and the hiding of the Impersonate button depending on a rule. Login at <a class="external-link" href="https://bbwt3-test-1.blueberrycf.com/app/edituser/c20bfdd4-07f7-4f56-9df8-1643360b9cae" rel="nofollow">https://bbwt3-test-1.blueberrycf.com/app/edituser/c20bfdd4-07f7-4f56-9df8-1643360b9cae</a> as an admin to see the Impersonate button. It would be nice if we created a bit of architecture to allow for asking whether a call to a particular API would be rejected (for a given resource). </p><h1 id="BBWT3-HowSecurityWorks-SecurityatDatabase">Security at Database</h1><p>Currently BBWT database security is typically limited to using one DB login only. With all users of the site effectively having equal access to the database, mitigated only by the Web API calls that they have permission to use. It would be nice if we created a bit of architecture to allow mapping of BBWT roles or users into the DB security, so that if a Web API call provides insufficient protection, the DB itself can reject a request. This would give additional protection against SQL injection attacks, or overly permissive user-reporting features. </p><h1 id="BBWT3-HowSecurityWorks-SecurityofSiteAdminFunctionality">Security of Site Admin Functionality</h1><p>Currently BBWT systems allow access to site admin and configuration features from any IP address and at the same URL as the rest of the site.   It would be nice if this access was narrowed down further, by e.g. insisting that site admin features only unlock upon access over a VPN, or with Two Factor Authentication. (31-01-19 <a class="external-link" href="https://ptsa.bbconsult.co.uk/taskEditor?type=3&amp;id=146376&amp;returnUrl=https%3A%2F%2Fptsa.bbconsult.co.uk%2F%2Ftasks" rel="nofollow">#146376</a>).</p>
                    </div>

                    
                 
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Nov 27, 2020 10:56</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
