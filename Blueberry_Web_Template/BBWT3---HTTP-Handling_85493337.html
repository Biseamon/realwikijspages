<!--
title: BBWT3---HTTP-Handling_85493337
description: 
published: true
date: 2020-12-01T16:47:34.469Z
tags: 
editor: undefined
dateCreated: 2020-11-27T11:04:38.509Z
-->

<!DOCTYPE html>
<html>
    <head>
        <title>Blueberry Group : BBWT3 - HTTP Handling</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">Blueberry Group</a></span>
                            </li>
                                                    <li>
                                <span><a href="Blueberry-Web-Template_85492520.html">Blueberry Web Template</a></span>
                            </li>
                                                    <li>
                                <span><a href="BBWT3_85492530.html">BBWT3</a></span>
                            </li>
                                                    <li>
                                <span><a href="BBWT3---Technical-Notes_85493335.html">BBWT3 - Technical Notes</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            Blueberry Group : BBWT3 - HTTP Handling
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
        
            Created by <span class='author'> Jason Cozza</span> on Sep 22, 2020
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <h1 id="BBWT3-HTTPHandling-Overview">Overview</h1><p>This page deals with how HTTP is handled.</p><h1 id="BBWT3-HTTPHandling-Back-endDetails">Back-end Details</h1><p><em>For more detailed <em>requirements</em> description for the HTTP requests handling on the back-end side, see here:</em><a class="external-link" href="https://ptsa.bbconsult.co.uk/#/taskEditor?type=3&amp;id=153264" rel="nofollow"> https://ptsa.bbconsult.co.uk/#/taskEditor?type=3&amp;id=153264</a></p><h2 id="BBWT3-HTTPHandling-CRUD">CRUD</h2><p>To make it easier to work with CRUD, was added an abstract class called <strong>CrudControllerBase</strong>, which is already inherited from ControllerBase.</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><code>public</code> <code>abstract</code> <code>class</code> <code>CrudControllerBase&lt;TEntityDTO, TKey&gt; : BBWM.Core.Web.ControllerBase</code><br/> <br/> <br/><code>public</code> <code>abstract</code> <code>class</code> <code>CrudControllerBase&lt;TEntityDTO&gt; : CrudControllerBase&lt;TEntityDTO, </code><code>int</code><code>&gt; </code><code>//(for the entities with the int type of id)</code><br/><code>    </code><code>where TEntityDTO : </code><code>class</code><code>, IDTO</code></p></td></tr></tbody></table></div><p><br/></p><pre>It includes these methods:</pre><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><code>// gets entity by ID</code><br/><code>[HttpGet, Route(</code><code>&quot;{id}&quot;</code><code>)]</code><br/><code>public</code> <code>virtual</code> <code>async Task&lt;IActionResult&gt; Get([IdBinder] TKey id, CancellationToken cancellationToken = </code><code>default</code><code>)</code><br/> <br/> <br/><code>// Creates entity</code><br/><code>[HttpPost]</code><br/><code>public</code> <code>virtual</code> <code>async Task&lt;IActionResult&gt; Create([FromBody] TEntityDTO dto, [FromServices] IModelHashingService modelHashingService, CancellationToken cancellationToken = </code><code>default</code><code>)</code><br/> <br/><code>// Updates entity</code><br/><code>[HttpPut, Route(</code><code>&quot;{id}&quot;</code><code>)]</code><br/><code>public</code> <code>virtual</code> <code>async Task&lt;IActionResult&gt; Update([FromBody] TEntityDTO dto, [IdBinder] TKey id, CancellationToken cancellationToken = </code><code>default</code><code>)</code><br/> <br/><code>// Deletes entity</code><br/><code>[HttpDelete, Route(</code><code>&quot;{id}&quot;</code><code>)]</code><br/><code>public</code> <code>virtual</code> <code>async Task&lt;IActionResult&gt; Delete([IdBinder] TKey id, CancellationToken cancellationToken = </code><code>default</code><code>)</code></p></td></tr></tbody></table></div><p><br/></p><p>This allows us to create controllers like this one:</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><code>[Route(</code><code>&quot;api/demo/organization&quot;</code><code>)]</code><br/><code>public</code> <code>class</code> <code>OrganizationController : CrudControllerBase&lt;OrganizationDTO&gt;</code><br/><code>{</code><br/><code>    </code><code>public</code> <code>OrganizationController(</code><br/><code>        </code><code>ICrudService&lt;OrganizationDTO&gt; service,</code><br/><code>        </code><code>ILogger&lt;OrganizationController&gt; logger) : </code><code>base</code><code>(service, logger)</code><br/><code>    </code><code>{</code><br/><code>    </code><code>}</code><br/> <br/><code>    </code><code>[HttpGet]</code><br/><code>    </code><code>public</code> <code>async Task&lt;IActionResult&gt; GetAll([FromQuery] Filter filter, CancellationToken cancellationToken = </code><code>default</code><code>) =&gt;</code><br/><code>        </code><code>Ok(await CrudService.GetAll(cancellationToken));</code><br/><code>}</code></p></td></tr></tbody></table></div><h1 id="BBWT3-HTTPHandling-Front-endDetails">Front-end Details</h1><p><em>For more detailed <em>requirements</em> description for the HTTP responses handling on the front-end side, see here: <a class="external-link" href="https://ptsa.bbconsult.co.uk/#/taskEditor?type=3&amp;id=153360" rel="nofollow">https://ptsa.bbconsult.co.uk/#/taskEditor?type=3&amp;id=153360</a></em></p><h2 id="BBWT3-HTTPHandling-Basics">Basics</h2><p>Just as with the back-end side, was added a basic abstract class, called <strong>BaseDataService</strong>, with a template handling method. All services that work with the back-end API must be inherited from it.<br/><strong>project/BBWT.Client/src/app/bbwt/modules/data-service/base.data.service.ts</strong></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><code>export </code><code>abstract</code> <code>class</code> <code>BaseDataService {</code><br/><code>    </code><code>protected</code> <code>constructor(</code><br/><code>        </code><code>protected</code> <code>http: HttpClient,</code><br/><code>        </code><code>protected</code> <code>handlersFactory: HttpResponsesHandlersFactory) {}</code><br/> <br/> <br/><code>    </code><code>protected</code> <code>handleRequest&lt;TResult&gt;(</code><br/><code>        </code><code>request: Observable&lt;TResult&gt;,</code><br/><code>        </code><code>responseHandler?: IHttpResponsesHandler): Promise&lt;TResult&gt; {</code><br/><code>        </code><code>...</code><br/><code>    </code><code>}</code><br/> <br/><code>    </code><code>protected</code> <code>constructHttpParams(obj: any): HttpParams {</code><br/><code>        </code><code>...   </code><br/><code>    </code><code>}</code><br/><code>}</code></p></td></tr></tbody></table></div><p>The template method here is <strong>handleRequest</strong>:</p><pre><span style="color: rgb(0,0,255);">protected </span><span style="color: rgb(122,122,67);">handleRequest</span>&lt;TResult&gt;(request: <span style="color: rgb(43,145,175);">Observable</span>&lt;TResult&gt;, reponseHandler: <span style="color: rgb(43,145,175);">IHttpResponsesHandler</span>) : <span style="color: rgb(43,145,175);">Promise</span>&lt;TResult&gt;</pre><p>It accepts the following parameters:</p><ol><li><p>request: <span style="color: rgb(43,145,175);">Observable</span>&lt;TResult&gt; - request to the server via HttpClient. For example: http.get ('some_url', params)</p></li><li><p>reponseHandler: <span style="color: rgb(43,145,175);">IHttpResponsesHandler</span> - a handlerObject. Depending on the request itself, we can process the server responses in different ways. More details about this below in this article.</p></li></ol><p>The typical example of using (about of using handlersFactory see below in this article):<br/><strong>project/BBWT.Client/src/app/bbwt/modules/data-service/base.data.service.ts</strong></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><code>export </code><code>class</code> <code>EmailService extends BaseDataService {</code><br/><code>    </code><code>private</code> <code>readonly</code> <code>url: </code><code>string</code> <code>= </code><code>&quot;api/send-email&quot;</code><code>;</code><br/> <br/><code>    </code><code>constructor(http: HttpClient, handlersFactory: HttpResponsesHandlersFactory) {</code><br/><code>        </code><code>super(http, handlersFactory);</code><br/><code>    </code><code>}</code><br/> <br/><code>    </code><code>public</code> <code>sendEmail(email: Email, attachments: File[]) {</code><br/><code>        </code><code>const</code> <code>formData: FormData = </code><code>new</code> <code>FormData();</code><br/> <br/><code>        </code><code>for</code> <code>(let i = 0; i &lt; attachments.length; i++) {</code><br/><code>            </code><code>formData.append(i.toString(), attachments[i], attachments[i].name);</code><br/><code>        </code><code>}</code><br/> <br/><code>        </code><code>Object.keys(email).forEach(key =&gt; {</code><br/><code>            </code><code>formData.append(key, email[key]);</code><br/><code>        </code><code>});</code><br/> <br/><code>        </code><code>return</code> <code>this</code><code>.handleRequest(</code><code>this</code><code>.http.post(</code><code>this</code><code>.url, formData), </code><code>null</code><code>);</code><br/><code>    </code><code>}</code><br/><code>}</code></p></td></tr></tbody></table></div><h3 id="BBWT3-HTTPHandling-IHttpResponsesHandler"><br/>IHttpResponsesHandler</h3><p>Depending of the request's context (Get by id, Get page) or HTTP method (GET, POST), we can handle results differently. To do this, we pass the IHttpResponsesHandler object to the template method.</p><p>This interface already implements a set of classes that are on the path: <strong>project/BBWT.Client/src/app/bbwt/modules/logging/<span style="color: rgb(0,0,0);">global-error-handler.ts</span></strong></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><code>export </code><code>interface</code> <code>IHttpResponsesHandler {</code><br/><code>    </code><code>handleSuccess?(): </code><code>void</code><code>;</code><br/><code>    </code><code>handleError?(errorResponse: HttpErrorResponse): </code><code>void</code><code>;</code><br/><code>}</code></p></td></tr></tbody></table></div><p><br/></p><p>There is a base class implementing this interface. It is worth it to inherit from your custom handlers. Also all standard classes of handlers are inherited from it.</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><code>export </code><code>class</code> <code>BaseHttpResponsesHandler implements IHttpResponsesHandler {</code><br/><code>    </code><code>constructor(</code><code>protected</code> <code>injector: Injector, </code><code>protected</code> <code>settings?: IHttpResponseHandlerSettings) { }</code><br/> <br/> <br/><code>    </code><code>public</code> <code>handleSuccess(): </code><code>void</code> <code>{</code><br/><code>        </code><code>if</code> <code>(</code><code>this</code><code>.settings &amp;&amp; </code><code>this</code><code>.settings.showSuccessMessage) {</code><br/><code>            </code><code>this</code><code>.showMessage(Message.Success(</code><code>this</code><code>.settings.successMessage ? </code><code>this</code><code>.settings.successMessage : </code><code>&quot;Operation succeed.&quot;</code><code>));</code><br/><code>        </code><code>}</code><br/><code>    </code><code>}</code><br/> <br/><code>    </code><code>public</code> <code>handleError(errorResponse: HttpErrorResponse): </code><code>void</code> <code>{</code><br/><code>        </code><code>if</code> <code>(</code><code>this</code><code>.settings &amp;&amp; </code><code>this</code><code>.settings.showErrorMessage == </code><code>false</code><code>) </code><code>return</code><code>;</code><br/> <br/><code>        </code><code>if</code> <code>(</code><code>this</code><code>.settings &amp;&amp; </code><code>this</code><code>.settings.errorStatusesMessages &amp;&amp; </code><code>this</code><code>.settings.errorStatusesMessages[errorResponse.status] != </code><code>null</code><code>) {</code><br/><code>            </code><code>this</code><code>.showMessage(Message.Error(</code><code>this</code><code>.settings.errorStatusesMessages[errorResponse.status]));</code><br/><code>            </code><code>return</code><code>;</code><br/><code>        </code><code>}</code><br/> <br/><code>        </code><code>this</code><code>.handleErrorHttpStatusCode(errorResponse);</code><br/><code>    </code><code>}</code><br/> <br/><code>    </code><code>protected</code> <code>handleErrorHttpStatusCode(errorResponse: HttpErrorResponse): </code><code>void</code> <code>{</code><br/><code>        </code><code>// app is in Offline mode</code><br/><code>        </code><code>const</code> <code>appOnlineService = </code><code>this</code><code>.injector.</code><code>get</code><code>(AppOnlineStateService, </code><code>null</code><code>);</code><br/><code>        </code><code>if</code> <code>(appOnlineService &amp;&amp; !appOnlineService.isAppOnline) {</code><br/><code>            </code><code>this</code><code>.handleOfflineModeError();</code><br/><code>            </code><code>return</code><code>;</code><br/><code>        </code><code>}</code><br/> <br/><code>        </code><code>switch</code> <code>(errorResponse.status) {</code><br/><code>            </code><code>case</code> <code>HttpStatusCodes.Status400BadRequest:</code><br/><code>                </code><code>this</code><code>.handleStatus400BadRequest(errorResponse);</code><br/><code>                </code><code>break</code><code>;</code><br/><code>            </code><code>case</code> <code>HttpStatusCodes.Status403Forbidden:</code><br/><code>                </code><code>this</code><code>.handleStatus403Forbidden(errorResponse);</code><br/><code>                </code><code>break</code><code>;</code><br/><code>            </code><code>case</code> <code>HttpStatusCodes.Status401Unauthorized:</code><br/><code>                </code><code>break</code><code>;</code><br/><code>            </code><code>default</code><code>:</code><br/><code>                </code><code>this</code><code>.handleOtherError(errorResponse);</code><br/><code>        </code><code>}</code><br/><code>    </code><code>}</code><br/> <br/><code>    </code><code>...</code><br/><code>}</code></p></td></tr></tbody></table></div><p><br/></p><p>As can be seen from the error handling method, this class defines a set of helper methods for handling the various &quot;bad&quot; HTTP statuses that are of interest to us. </p><p>In this class, these methods have a different implementation by default, but you can override them in your inheritance classes.</p><h3 id="BBWT3-HTTPHandling-HttpResponsesHandlersFactory">HttpResponsesHandlersFactory</h3><p>For the convenience of creating standard handlers, the factory class <strong>HttpResponsesHandlersFactory</strong> was created:</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><code>export </code><code>class</code> <code>HttpResponsesHandlersFactory {</code><br/><code>    </code><code>constructor(</code><code>private</code> <code>injector: Injector) {</code><br/><code>    </code><code>}</code><br/> <br/><code>    </code><code>getDefault(settings?: IHttpResponseHandlerSettings): IHttpResponsesHandler {...}</code><br/><code>    </code><code>getForReadById(entityTitle: </code><code>string</code><code>, settings?: IHttpResponseHandlerSettings): IHttpResponsesHandler {...}</code><br/><code>    </code><code>getForReadByFilter(settings?: IHttpResponseHandlerSettings): IHttpResponsesHandler {...}</code><br/><code>    </code><code>getForReadAll(settings?: IHttpResponseHandlerSettings): IHttpResponsesHandler {...}</code><br/><code>    </code><code>getForCreate(entityTitle: </code><code>string</code><code>, settings?: IHttpResponseHandlerSettings): IHttpResponsesHandler {...}</code><br/><code>    </code><code>getForUpdate(entityTitle: </code><code>string</code><code>, settings?: IHttpResponseHandlerSettings): IHttpResponsesHandler {...}</code><br/><code>    </code><code>getForDelete(entityTitle: </code><code>string</code><code>, settings?: IHttpResponseHandlerSettings): IHttpResponsesHandler {...}</code><br/><code>}</code></p></td></tr></tbody></table></div><p>As you can see, it has many methods for creating and initializing various IHttpResponsesHandler classes.</p><h2 id="BBWT3-HTTPHandling-CRUD.1">CRUD</h2><p>Similarly to the back-end side, there is a class similar to <strong>CrudControllerBase </strong>which are inherited from <strong>BaseDataService</strong>:<br/><strong>project/BBWT.Client/src/app/bbwt/modules/data-service/crud.service.ts</strong></p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><code>export </code><code>abstract</code> <code>class</code> <code>CrudService&lt;TEntity&gt; extends BaseDataService {...}</code></p></td></tr></tbody></table></div><p><span>Implements all standard methods of CRUD queries. Since it is inherited from </span><strong>BaseDataService</strong><span>, all its methods use the functionality of the template </span><strong>handleRequest</strong><span> method.</span></p><p>After that, a typical CRUD class would look like this:</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><td class="confluenceTd"><p><code>export </code><code>class</code> <code>OrganizationService extends CrudService&lt;Organization&gt; {</code><br/><code>    </code><code>public</code> <code>readonly</code> <code>url = </code><code>&quot;api/demo/organization&quot;</code><code>;</code><br/><code>    </code><code>public</code> <code>readonly</code> <code>entityTitle = </code><code>&quot;Organization&quot;</code><code>;</code><br/> <br/> <br/><code>    </code><code>constructor(http: HttpClient, handlersFactory: HttpResponsesHandlersFactory) {</code><br/><code>        </code><code>super(http, handlersFactory);</code><br/><code>    </code><code>}</code><br/><code>}</code></p></td></tr></tbody></table></div><p><br/></p><p>It implements all CRUD methods, All of them are connected to the mechanism of HTTP responses processing.</p>
                    </div>

                    
                 
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Nov 27, 2020 10:56</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
