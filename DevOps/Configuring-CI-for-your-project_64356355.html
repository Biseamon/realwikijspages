<!--
title: Configuring-CI-for-your-project_64356355
description: 
published: true
date: 2020-12-03T14:57:59.282Z
tags: 
editor: undefined
dateCreated: 2020-12-03T14:57:57.285Z
-->

<!DOCTYPE html>
<html>
    <head>
        <title>Blueberry : Configuring CI for your project</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">Blueberry</a></span>
                            </li>
                                                    <li>
                                <span><a href="DevOps-Information_36144018.html">DevOps Information</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            Blueberry : Configuring CI for your project
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
        
            Created by <span class='author'> Unknown User (ahk)</span>, last modified on Oct 16, 2018
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <p>This article assumes that you have a basic understanding of Git and GitLab.</p><p>You've set your project up on GitLab, and you now want to enable continuous building and continuous delivery of your project. The first thing to consider is where the building and deploying will occur. You may have already set up a project-specific runner which is designed to build the project, in which case skip ahead to the final sections of this article.</p><p>GitLab uses a .gitlab-ci.yml file in the root of a repository to define the CI/CD pipelines for a project. It's recommended that you refer to the <a class="external-link" href="https://docs.gitlab.com/ce/ci/variables/" rel="nofollow">GitLab CI Variables</a> article while reading this article.</p><h1 id="ConfiguringCIforyourproject-Docker(Linux)basedbuilds">Docker (Linux) based builds</h1><p>If your project can be built using a linux-based docker image, e.g. from <a class="external-link" href="https://dockerhub.com" rel="nofollow">DockerHub</a> or from a repository on GitLab's registry, then use this section of the article.</p><div class="confluence-information-macro confluence-information-macro-information"><span class="aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>The examples here will assume you're building an asp.net core project using Microsoft's official docker images.</p></div></div><p><span style="letter-spacing: 0.0px;">First, you'll want to find the test the build locally to ensure the docker image you intend to use is fit for purpose. This can be done by using bind mounts to mount your project directory within the docker container, e.g (assuming ${PWD} is the project root:</span></p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: bash; gutter: false; theme: Midnight" data-theme="Midnight">docker run --rm -v ${PWD}:/src -it microsoft/dotnet:2.1-sdk cd /src &amp;&amp; dotnet build -c Debug</pre>
</div></div><p>This will run the `dotnet build -c Debug` command in the context of the '/src' directory, which is mapped to the project root on the docker host.</p><p>To translate this into a CI job, we could use the following definition in our .gitlab-ci.yml file:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: yml; gutter: true; theme: Midnight" data-theme="Midnight">image: microsoft/dotnet:2.1-sdk


stages:
  - build


build-app:
  stage: build
  only:
    - Development
  script:
    - &#39;dotnet restore&#39;
    - &#39;dotnet publish --no-restore -c Debug -o ${CI_PROJECT_DIR}/build/ --version-suffix ${CI_PIPELINE_ID}-${CI_COMMIT_SHA:0:8}-${CI_PROJECT_ID}&#39;
  artifacts:
    name: &quot;${CI_JOB_NAME}-${CI_COMMIT_REF_NAME}&quot;
    paths:
      - build

</pre>
</div></div><p>Let's break down the structure of this CI block.</p><p>Specifying 'image:' as a top-level directive means that it's used for any jobs in this CI where image is not specified, i.e. as a default.</p><p>We then specify the broad stages within our pipelines. For now, we'll just use one.</p><p>Next, we define our first job. Job names must be unique. Note that:</p><ul><li>We assign the job to a stage using 'stage:'.</li><li>We restrict the job to only run on commits to the 'Development' branch.</li></ul><p>Within the job, we have defined a 'script:' block, which allows us to specify the commands required to build the project.</p><p>Here, we're taking advantage of the dotnet command line to do the following:</p><ul><li>Restore dependencies for the solution</li><li>Publish the solution using the 'Debug' configuration into the 'build' directory</li><li>Pass in the pipeline ID, first 8 characters of the commit hash, and the project ID as the version suffix (the app can then access this at runtime if needed)</li></ul><p>After the script block is the 'artifacts:' block, where we instruct GitLab to collect the 'build/' folder and treat it as our job artifact. We also assign this a useful name, which in this case would evaluate to 'build-app-Development'.</p><p>Now let's say that we had an additional branch running alongside Development called Test. We want to deploy the software to a target whenever a merge or commit to this branch is made. In this case, we could amend the CI to look like this:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: yml; gutter: false; theme: Midnight" data-theme="Midnight">image: microsoft/dotnet:2.1-sdk

stages:
  - build
  - deploy

build-app:
  stage: build
  only:
    - Development
    - Test
  script:
    - &#39;dotnet restore&#39;
    - &#39;dotnet publish --no-restore -c Debug -o ${CI_PROJECT_DIR}/build/ --version-suffix ${CI_PIPELINE_ID}-${CI_COMMIT_SHA:0:8}-${CI_PROJECT_ID}&#39;
  artifacts:
    name: &quot;${CI_JOB_NAME}-${CI_COMMIT_REF_NAME}&quot;
    paths:
      - build


deploy-app:
  stage: deploy
  only:
    - Test
  environment:
    name: internal-test
    url: https://internal-test.example.com
  script:
    - &#39;&#39;

</pre>
</div></div><p>Note that we've added a new job which only runs on commits/merges to the 'Test' branch, but we've also added 'Test' to the candidate branches in the 'build-app' phase. This gives two possible pipelines depending on which branch the commit is made on, e.g:</p><p style="text-align: center;">Development: &lt;build-app&gt;</p><p style="text-align: center;">Test: &lt;build-app&gt; → &lt;deploy-app&gt;</p><p style="text-align: left;">By default, artifacts specified in a previous stage are automatically restored in jobs in the next stage. In this case, the 'build/' folder we specified earlier would be restored and made available when the 'deploy-app' job runs. This way, we can take the contents of the build folder and deploy it using whatever deployment method we need.</p><p style="text-align: left;">Note the additional 'environment:' block. Whatever we define here will become listed in the project's 'Operations → Environments' page, allowing you to keep track of deployments.</p><h1 style="text-align: left;" id="ConfiguringCIforyourproject-Usingasharedrunner">Using a shared runner</h1><p>By default, all jobs will run on the shared 'master' runner, which is a linux-based docker runner.</p><p>If you want to use a specific shared runner, specify the a 'tags:' block in the job configuration. Example:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: yml; gutter: false; theme: Midnight" data-theme="Midnight">deploy-app:
  stage: deploy
  only:
    - Test
  environment:
    name: internal-test
    url: https://internal-test.example.com
  script:
    - &#39;&#39;
  tags:
    - windows
    - reportingservices</pre>
</div></div><p>In this example, the job would look for a runner which had <strong>both</strong> the 'windows' and 'reportingservices' tags. If this requirement cannot be satisfied, the job will be stuck in a pending state until a runner becomes available, the job is cancelled, or the job expires.</p><h1 id="ConfiguringCIforyourproject-Usingaproject-specificrunner">Using a project-specific runner</h1><p>If you want your project to have exclusive access to a runner, then navigate to the 'Settings → CI/CI → Runners' page in your project. Here, you can register a new runner for your project and optionally exclude the project from using shared runners. If using a project-specific runner, <strong>remember to tag your</strong> <strong>runners/job(s) appropriately.</strong></p><p>Sometimes it's useful to have a project-specific runner as the configuration to build the project is quite unique or exotic i.e. a legacy .NET Framework project with third party dependencies which can't be satisfied with NuGet.</p><div class="confluence-information-macro confluence-information-macro-warning"><span class="aui-icon aui-icon-small aui-iconfont-error confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>If using a Windows runner, note that environment variables are expanded like %EXAMPLE% instead of ${EXAMPLE}</p></div></div>
                    </div>

                    
                 
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Dec 03, 2020 14:51</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
