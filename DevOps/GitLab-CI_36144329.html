<!DOCTYPE html>
<html>
    <head>
        <title>Blueberry : GitLab CI</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">Blueberry</a></span>
                            </li>
                                                    <li>
                                <span><a href="DevOps-Information_36144018.html">DevOps Information</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            Blueberry : GitLab CI
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
        
            Created by <span class='author'> Unknown User (ahk)</span>, last modified by <span class='editor'> Alex Putnam</span> on Aug 31, 2020
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <div class="contentLayout2">
<div class="columnLayout single" data-layout="single">
<div class="cell normal" data-type="normal">
<div class="innerCell">
<p>GitLab CI is a tool in GitLab which allows users to continuously build and deploy new revisions of their applications. Our GitLab is configured to use Docker for builds, allowing build pristine build environments. Blueberry uses GitLab CI with Web Template 3.</p><p>For a list of GitLab CI variables, refer to <a class="external-link" href="https://docs.gitlab.com/ce/ci/variables/" rel="nofollow">this documentation.</a> These variables can be used anywhere within the file.</p><p>For a comprehensive breakdown of the CI language, see <a class="external-link" href="https://docs.gitlab.com/ce/ci/yaml/" rel="nofollow">this page.</a></p><p>The CI definition is stored within the root of a given repository in the .gitlab-ci.yml file. Here's a basic example which can build bbwt3:</p></div>
</div>
</div>
<div class="columnLayout two-equal" data-layout="two-equal">
<div class="cell normal" data-type="normal">
<div class="innerCell">
<div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: csharp; gutter: false; theme: Midnight" data-theme="Midnight">image : microsoft/aspnetcore-build

variables:
  AWS_DEFAULT_REGION: &quot;eu-west-1&quot;

stages:
  - build
  - deploy

cache:
  key: &quot;${CI_JOB_NAME}/${CI_COMMIT_REF_NAME}&quot;
  paths:
  - project/BBWT.Client/node_modules/
  - ${HOME}/.nuget/packages/
  
before_script:
 - &#39;apt-get -qq update&#39;
  
build:
 stage: build
 script:
  - &#39;dotnet restore&#39;
  - &#39;dotnet publish -c Release -o out&#39;
  - &#39;mkdir build&#39;
  - &#39;mv project/BBWT.Server/out/* build&#39;
 artifacts:
  name: &quot;${CI_JOB_NAME}-${CI_COMMIT_REF_NAME}&quot;
  when: on_success
  paths:
  - build
 only:
  - master

deploy/dev:
  stage: deploy
  script:
   - &#39;apt-get -qq install python-pip zip&#39;
   - &#39;pip install --upgrade pip awscli&#39;
   - &#39;pushd build&#39;
   - &#39;zip &quot;${CI_PROJECT_DIR}/app.zip&quot; -r ./*&#39;
   - &#39;popd&#39;
   - &#39;zip &quot;${CI_PROJECT_NAME}-${CI_COMMIT_REF_NAME}.zip&quot; aws-windows-deployment-manifest.json app.zip&#39;
   - &#39;aws s3 cp &quot;${CI_PROJECT_NAME}-${CI_COMMIT_REF_NAME}.zip&quot; s3://bb.gitlab.artifacts/&#39;
   - &#39;aws elasticbeanstalk create-application-version --application-name &quot;Blueberry Web Template 3&quot; --version-label ${CI_COMMIT_SHA} --source-bundle S3Bucket=&quot;bb.gitlab.artifacts&quot;,S3Key=&quot;${CI_PROJECT_NAME}-${CI_COMMIT_REF_NAME}.zip&quot;&#39;
   - &#39;while [[ &quot;$(aws elasticbeanstalk describe-environments --environment-ids ${ELASTICBEANSTALK_ENV_ID} --query Environments[0].Status --output=text)&quot; != &quot;Ready&quot; ]]; do sleep 5; done;&#39;
   - &#39;aws elasticbeanstalk update-environment --environment-id ${ELASTICBEANSTALK_ENV_ID} --version-label ${CI_COMMIT_SHA}&#39;
  environment:
    name: dev
    url: https://bbwt3.blueberrytest.com
  only:
   - master</pre>
</div></div></div>
</div>
<div class="cell normal" data-type="normal">
<div class="innerCell">
<p class="auto-cursor-target">The <strong>image</strong> stanza defines a docker image to use, as listed on Docker Hub. By default, it pulls the latest version of the image, but appending a version number after a colon (i.e. microsoft/aspnetcore-build:1.4) will use a specific version. This image can be overwritten at an individual job level if required.</p><p>We can also define global variables at the top of the file, to be used later on.</p><p>The CI file is divided into <strong>stages</strong>, which are further divided into <strong>jobs</strong>. A stage can have as many jobs as required, which are executed in parallel. Artifiacts from a previous stage are made available to the jobs in the next stage with the <strong>artifacts</strong> definition. In our example to the side, the artifacts from the <strong>build</strong> stage would be available to the <strong>deploy</strong> stage. We define the stages and their order at the top of the CI file.</p><p>The <strong>cache</strong> stanza defines which paths the CI system should cache within the docker image, thereby saving some time and bandwidth. In this example, we're caching the node and nuget packages, but the cache is invalidated if the CI commit reference changes, i.e. we're running CI against a different commit.</p><p>The <strong>before_script</strong> stanza is a script section which will run before every <strong>script</strong> section within a job. In this case, we're running <strong>apt-get update</strong> in our containers to prep them for any package installations we might need.</p><p>Now we come to our first job definition. The job name itself is arbitrary and is <strong>not</strong> dependant on the stage it is part of. Hopefully the <strong>stage</strong> and <strong>script</strong> sections are self-explanatory. We're simply telling the system which CI stage this job belongs to, and what commands to run. The script section is effectively a bash shell and allows you to run any command you need to build the software. In our case, we're running <strong>dotnet</strong>, as part of the docker image we defined earlier, and building and then publishing Web Template 3. We then make a directory in the CI root, and move the published site there for GitLab CI to collect in the <strong>artifacts</strong> stanza.</p><p>The <strong>artifacts</strong> stanza defines the artifacts that will be passed between CI stages and ultimately published to the Pipelines page for download. The (optional) <strong>name</strong> allows us to give the published ZIP file a custom name. <strong>when</strong> (optional) defines when the artifact should be published - in this case we only want it if the job succeeded. <strong>paths</strong> is a list of paths to be zipped up and published, and passed to the next CI stage, in this case the build folder we created earlier.</p><p>Finally, the <strong>only</strong> stanza tell the CI system to only run this job on commits to the master branch of the repository.</p><p>Onto our next stage (<strong>deploy</strong>) and job (<strong>deploy/dev</strong>), we're installing the AWS CLI tools through PIP, which is itself installed through APT. We then create a ZIP file within the build directory that we retrieved automatically from the previous stage, pop back to the CI root, and add the deployment manifest (which itself exists at the root of the repository). We then copy this to an S3 bucket, and then create a new Elastic Beanstalk app version referencing this new bucket object, with the commit hash as the version string for easy cross-reference with the git repository. Finally, we tell Elastic Beanstalk to use this new app version. Not the <strong>$ELASTICBEANSTALK_ENV_ID</strong> variable, which is a secret pipeline variable within GitLab CI. You can define secret pipeline variables in the <strong>Settings &gt; CI/CD Pipelines</strong> page of the repository.</p><div class="confluence-information-macro confluence-information-macro-information"><span class="aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>We don't require IAM keys as the GitLab server uses an IAM role to interact with AWS, which the CLI tools will use to fetch temporary credentials with.</p></div></div><p>The <strong>environment</strong> stanza allows GitLab to track the deployments and provide rollback functionality, which is then exposed in the <strong>Pipelines &gt; Enviroments</strong> page.</p><p>By default, the entire pipeline will fail if one job fails. This can be overridden at the individual job level using the <strong>allow_failure</strong> directive. Again, see the <a class="external-link" href="https://docs.gitlab.com/ce/ci/yaml/" rel="nofollow">complete reference</a> for details.</p><p>When creating a new implementation, plan out the stages and then think about the jobs required by each stage. If you can parallelise the jobs (e.g. multiple test suites) then do so, but be aware of the dependent nature of the pipeline graph.</p></div>
</div>
</div>
<div class="columnLayout two-equal" data-layout="two-equal">
<div class="cell normal" data-type="normal">
<div class="innerCell">
<h1 id="GitLabCI-Integratingunittests">Integrating unit tests</h1><p>You may need to integrate unit testing into a CI workflow. To do this, create a new stage with a job or two, like so:</p></div>
</div>
<div class="cell normal" data-type="normal">
<div class="innerCell">
<p><br/></p></div>
</div>
</div>
<div class="columnLayout two-equal" data-layout="two-equal">
<div class="cell normal" data-type="normal">
<div class="innerCell">
<div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: csharp; gutter: true; theme: Midnight" data-theme="Midnight">test/backend:
  stage: test
  before_script: []
  script:
    - &#39;pushd test/BBWT.Services.Test&#39;
    - &#39;dotnet restore&#39;
    - &#39;dotnet xunit -xml ${CI_PROJECT_DIR}/xunit-result.xml&#39;
    - &#39;dotnet build -o ${CI_PROJECT_DIR}/testdll&#39;
    - &#39;popd&#39;
    - &#39;ls testdll/*.Test.dll | xargs dotnet vstest --logger:&quot;trx;LogFileName=vstest-result.trx&quot;&#39;
  artifacts:
    name: &quot;${CI_PROJECT_NAME}-${CI_COMMIT_REF_NAME}-${CI_JOB_NAME}&quot;
    paths:
    - xunit-result.xml
    - TestResults
  only:
    - Development
    - master


test/karma:
  stage: test
  before_script:
   - &#39;echo &quot;deb http://dl.google.com/linux/chrome/deb/ stable main&quot; &gt;&gt; /etc/apt/sources.list&#39;
   - &#39;apt-get -qq update&#39;
   - &#39;apt-get -qq install --no-install-recommends --allow-unauthenticated google-chrome-stable&#39;
  script:
   - &#39;pushd project/BBWT.Client&#39;
   - &#39;npm install&#39;
   - &#39;npm test&#39;
   - &#39;mv karma-test-results.trx ${CI_PROJECT_DIR}/&#39;
  artifacts:
    name: &quot;${CI_PROJECT_NAME}-${CI_COMMIT_REF_NAME}-${CI_JOB_NAME}&quot;
    paths:
    - &#39;karma-test-results.trx&#39;
  only:
    - Development
    - master</pre>
</div></div></div>
</div>
<div class="cell normal" data-type="normal">
<div class="innerCell">
<p>Note how we're creating an empty <strong>before_script</strong> section - this overrides the global one we defined before.</p><p>This example will cover both running with XUnit directly and VSTest. First, the <strong>test/backend</strong> job.</p><p>In this <strong>script</strong> example, we're changing into the <strong>test/BBWT.Services.Test</strong> directory as the test project has its own set of dependencies, and the XUnit test runner can only run within the context of the test directory. After restoring, we run <strong><a class="external-link" href="https://xunit.github.io/docs/getting-started-dotnet-core" rel="nofollow">dotnet</a></strong><a class="external-link" href="https://xunit.github.io/docs/getting-started-dotnet-core" rel="nofollow"> xunit</a> and tell it to place the resulting XML in the CI root.</p><p>Next, we build the project and tell it to drop files into the <strong>testdll</strong> folder in the CI root, and we then pop back to the CI root. We pipe together the <strong>ls</strong> command, getting a space-separated list of testing DLLs which we then parse with <strong>xargs</strong> which then feeds the results into <strong>dotnet vstest</strong>, the integrated test runner, which we tell to emit a TRX file. The TRX file is placed in a subfolder, <strong>TestResults</strong>, of the CI root. We then collect these using the artifacts feature of GitLab CI.</p><p>In the <strong>test/karma</strong> job, which will be running in parallel to the previous job, we install the latest version of Google Chrome from Google's official APT repositories. We've skipped adding their keys for authentication as they were broken in any case when I tried. We're doing this to ensure we grab a version of Chrome with the headless mode, which negates the need to set up an X virtual framebuffer and all the headaches that come with that.</p><p>In the script section, we're installing the <strong>node</strong> dependencies using <strong>npm</strong>, and then using <strong>npm</strong> to run the <strong>karma</strong> front-end tests. After running the test, we collect the TRX file that karma produced, to be used in a later step for example.</p><div class="confluence-information-macro confluence-information-macro-information"><span class="aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>Note that in both examples we're running tests on commits to both the Development and master branches.</p></div></div></div>
</div>
</div>
<div class="columnLayout single" data-layout="single">
<div class="cell normal" data-type="normal">
<div class="innerCell">
<h1 id="GitLabCI-IntegratingSonarQube">Integrating SonarQube</h1><p>You may need to integrate SonarQube analysis into the CI flow. Create a new job and stage as exampled below.</p></div>
</div>
</div>
<div class="columnLayout two-equal" data-layout="two-equal">
<div class="cell normal" data-type="normal">
<div class="innerCell">
<div class="code panel pdl" style="border-width: 1px;"><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: csharp; gutter: true; theme: Midnight" data-theme="Midnight">sonarqube:
  stage: analysis
  image: accesto/gitlab-sonar-runner
  before_script: []
  script:
   - &#39;${SONAR_RUNNER_HOME}/bin/sonar-runner -Dsonar.projectVersion=${CI_BUILD_ID} -Dsonar.login=${SONAR_LOGIN}&#39;
  only:
    - master
  when: manual</pre>
</div></div><p class="auto-cursor-target">We also need another file defined at the root of the repository, with the name <strong>sonar-project.properties</strong>:</p><div class="code panel pdl" style="border-width: 1px;"><div class="codeHeader panelHeader pdl" style="border-bottom-width: 1px;"><b>sonar-project.properties</b></div><div class="codeContent panelContent pdl">
<pre class="syntaxhighlighter-pre" data-syntaxhighlighter-params="brush: csharp; gutter: false; theme: Midnight" data-theme="Midnight">sonar.projectName=BBWT3 :: Blueberry Web Template 3
sonar.projectKey=bbwt3:vme
sonar.sources=src
sonar.tests=test
sonar.exclusions=**/wwwroot
sonar.host.url=https://sonar.bbconsult.co.uk</pre>
</div></div><p class="auto-cursor-target">The <strong>sonar-runner</strong> tool will use these properties automatically. It's a good idea to place static configuration properties in this file, whereas anything dynamic like variables should be defined in the CI job.</p></div>
</div>
<div class="cell normal" data-type="normal">
<div class="innerCell">
<p>We've defined a new stage, <strong>analysis</strong>, with a job called <strong>sonarqube</strong>.</p><p>Note that we're overriding the global <strong>image</strong> directive and using one with the sonar runner bundled, making our life easier.</p><p>The script section is simple, and calls the <strong>sonar-runner</strong> binary with several arguments:</p><ul><li><pre>sonar.projectVersion=${CI_BUILD_ID}</pre><ul><li><p>We use the CI build ID for the version reported in Sonar</p></li></ul></li><li><pre>sonar.login=${SONAR_LOGIN}</pre><ul><li><p>A secret API token generated in SonarQube, defined in the repository's CI/CD Pipeline settings.</p></li></ul></li></ul><p>In the <strong>sonar-project.properties</strong> file, the following should be defined at a minimum:</p><ul><li>sonar.projectName - the project name as it exists on SonarQube</li><li>sonar.projectKey - the project key as it exists on SonarQube</li><li>sonar.host.url - the URL of the SonarQube installation</li></ul><p>While SonarQube can guess where the source code and tests are, it's good to explicitly set the locations:</p><ul><li>sonar.sources - the source code folder in the repository</li><li>sonar.tests - the tests directory in the repository</li></ul><p>If you need certain files or folders excluded from analysis (such as vendor code), use:</p><ul><li>sonar.exclusions - comma separated list of excluded source files</li><li><p>sonar.test.exclusions - comma separated list of excluded test files</p></li></ul><div class="table-wrap"><table class="wrapped confluenceTable"><colgroup><col/><col/></colgroup><thead><tr><th class="confluenceTh"><p>Wildcard</p></th><th class="confluenceTh"><p>Matches</p></th></tr></thead><tbody><tr><td class="confluenceTd">*</td><td class="confluenceTd">zero or more characters</td></tr><tr><td class="confluenceTd">**</td><td class="confluenceTd">zero or more directories</td></tr><tr><td class="confluenceTd">?</td><td class="confluenceTd">a single character</td></tr></tbody></table></div><p>See the <a class="external-link" href="https://docs.sonarqube.org/display/SONAR/Narrowing+the+Focus" rel="nofollow">official documentation</a> for further help.</p><ul><li><p>sonar.cs.vstest.reportPaths - A VSTEST (e.g. TRX) file to be included in the final Sonar report</p></li><li><p>sonar.cs.xunit.reportsPaths - An Xunit XML file to be included in the final Sonar report</p></li></ul><div class="confluence-information-macro confluence-information-macro-information"><span class="aui-icon aui-icon-small aui-iconfont-info confluence-information-macro-icon"></span><div class="confluence-information-macro-body"><p>It's unclear if the above two options are mutually exclusive.</p></div></div></div>
</div>
</div>
<div class="columnLayout single" data-layout="single">
<div class="cell normal" data-type="normal">
<div class="innerCell">
<h1 id="GitLabCI-AdministratingGitLabCI">Administrating GitLab CI</h1><p>GitLab CI runs on the main GitLab server using Docker containers through a <strong>CI runner</strong>. A CI runner is similar to a Jenkins node/slave and executes CI tasks according to its configuration (e.g on the bare server, in a docker environment etc.). Administration is mostly hands-off, but you can diagnose issues by logging onto the server over SSH and checking the status of docker using the docker shell e.g. <strong>sudo docker ps</strong></p><p>Runners can be arbitrarily tagged, and then projects can be configured to only run on certain tagged runners. This could be useful to distinguish between Windows and Linux build hosts for example.</p><p>The CI runners can be administrated from <a class="external-link" href="https://gitlab.bbconsult.co.uk/admin/runners" rel="nofollow">this page.</a></p><p><span style="font-size: 24.0px;">Elastic Beanstalk issues</span></p><p>If you need to re-run a deployment within CI, Elastic Beanstalk might complain about an already existing application version. In this case, delete the application version from within the Elastic Beanstalk console.</p></div>
</div>
</div>
</div>
<div class="jfk-bubble gtx-bubble" style="visibility: visible;left: 154.0px;top: 2138.0px;" />
                    </div>

                    
                 
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Dec 03, 2020 14:51</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
